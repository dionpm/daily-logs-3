<!DOCTYPE html>
<html lang="en">
<!--
  Daily Logs Application

  This single‑file web app implements a simple logging tool for
  water/boiler/cooling tower operations.  It is designed to run
  entirely in the browser and persist data either locally (via
  localStorage) or remotely via Firebase Firestore.  The goal is
  to support multiple users entering daily test values, track
  meter readings with automatic makeup calculations, highlight
  values that fall outside of user‑defined ranges, and provide a
  basic trending interface.

  Features:
    • Daily view for entering readings for a single date.  Users
      select a system (e.g. Cooling Tower 1, Chilled Loop) and a
      date.  The app builds a grid of points (equipment) and
      fields (readings) where values can be typed in.  For fields
      designated as meter readings, the app automatically
      calculates delta (makeup) and a running total for the month.
    • Monthly view that builds a table spanning the entire
      month with days across columns and point/field rows.  This
      is useful for printing or reviewing a month at a glance.
    • Settings tab where administrators can add/edit systems,
      points and fields, define high/low ranges for each field,
      and switch between local and Firebase storage.  A short
      Firebase configuration form is provided – paste your
      project details here to enable multi‑user sync.
    • Trends tab that renders a line chart (via Chart.js) for
      any point/field over a date range.  This allows quick
      inspection of trends without exporting to a spreadsheet.

  The application stores its configuration under the key
  `dailyLogConfig` and daily logs under `dailyLogData` in
  localStorage.  When Firebase is enabled the same structures are
  persisted to Firestore under the provided namespace.

  Written August 2025.
-->
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Daily Test Log</title>
  <!-- Chart.js for trends -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Firebase (optional) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <!-- SheetJS (XLSX) for Excel exports -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root {
      --bg: #0f1320;
      --card: #161a2b;
      --ink: #e8eaf6;
      --muted: #a6accd;
      --accent: #8ab4f8;
      --border: #2a3152;
      --danger: #ff6b6b;
      --good: #4caf50;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto;
      overflow-y: scroll;
    }
    header {
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    header h1 {
      font-size: 18px;
      margin: 0;
    }
    nav.tabs {
      display: flex;
      gap: 8px;
      padding: 8px;
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
    }
    .tab {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0e1221;
      color: var(--ink);
      cursor: pointer;
    }
    .tab.active {
      background: #1a2040;
      border-color: #3a4370;
    }
    .tab-content {
      display: none;
      padding: 12px;
    }
    .tab-content.active { display: block; }
    .wrap {
      max-width: 1300px;
      margin: 0 auto;
      padding: 12px;
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 12px;
    }
    @media (max-width:900px) { .wrap { grid-template-columns: 1fr; } }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }
    .card h2 {
      font-size: 16px;
      margin: 0 0 8px;
    }
    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 10px 0 6px;
    }
    input, select, button, textarea {
      width: 100%;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0e1221;
      color: var(--ink);
    }
    button { cursor: pointer; }
    textarea { min-height: 120px; }
    option { color: #000; }
    .toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: end;
    }
    .toolbar > div { flex: 1; min-width: 160px; }
    .note { font-size: 12px; color: var(--muted); }
    .gridControls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      margin: 6px 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background: #0d1120;
      border: 1px solid var(--border);
      font-size: 13px;
    }
    th, td {
      border: 1px solid var(--border);
      padding: 6px 8px;
      text-align: center;
    }
    th {
      background: #11162a;
      color: #c7ceea;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .sticky-col {
      position: sticky;
      left: 0;
      background: #10162b;
      z-index: 2;
    }
    .cell { min-width: 64px; }
    .cell[contenteditable="true"] { outline: none; }
    .cell:focus { box-shadow: 0 0 0 2px var(--accent) inset; }
    .low-cell { background: rgba(76, 175, 80, 0.2); }  /* green */
    .high-cell { background: rgba(255, 107, 107, 0.2); }/* red */
    .ok-cell { background: transparent; }
    /* Hide computed cells caret */
    .computed { user-select: none; }
    /* Input used inside editable cells to improve caret behavior */
    .cell-input {
      width: 100%;
      background: transparent;
      border: none;
      outline: none;
      color: inherit;
      padding: 0;
      margin: 0;
      text-align: center;
      /* Prevent iOS Safari from zooming on focus by setting minimum font-size */
      font-size: 16px;
    }
    /* Print styles */
    @media print {
      body { background: #fff; color: #000; }
      header, .no-print { display: none !important; }
      .wrap { grid-template-columns: 1fr; }
      .card { border: none; padding: 0; }
      th, td { border: 1px solid #777; color: #000; }
      th { background: #eee; color: #000; }
      .sticky-col { position: static; background: #fff; }
    }
    /* Small utility button used in settings for add/delete operations */
    .small-btn {
      font-size: 12px;
      padding: 2px 6px;
      margin-left: 4px;
      background: var(--border);
      color: var(--ink);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
    }
    .small-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }
  </style>
</head>
<body>
  <header>
    <h1>Daily Test Log</h1>
    <span class="note">Offline capable. Use Settings to configure storage and systems.</span>
  </header>
  <nav class="tabs">
    <button class="tab active" data-target="daily">Daily</button>
    <button class="tab" data-target="monthly">Monthly</button>
    <button class="tab" data-target="settings">Settings</button>
    <button class="tab" data-target="trends">Trends</button>
  </nav>

  <!-- Daily Tab Content -->
  <div id="daily" class="tab-content active">
    <div class="wrap">
      <div class="card" id="dailyControls">
        <h2>Controls</h2>
        <div class="toolbar">
          <div>
            <label for="dailySystem">System</label>
            <select id="dailySystem"></select>
          </div>
          <div>
            <label for="dailyDate">Date</label>
            <input id="dailyDate" type="date"/>
          </div>
          <div>
            <button id="prevDay">◀ Prev</button>
            <button id="nextDay">Next ▶</button>
          </div>
        </div>
        <p class="note">Select a system and date to build the grid.</p>
      </div>
      <div class="card" id="dailyGridCard">
        <h2 id="dailyGridTitle">Daily View</h2>
        <div id="dailyGridContainer">
          <!-- grid inserted here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Monthly Tab Content -->
  <div id="monthly" class="tab-content">
    <div class="wrap">
      <div class="card" id="monthlyControls">
        <h2>Monthly Controls</h2>
        <div class="toolbar">
          <div>
            <label for="monthlySystem">System</label>
            <select id="monthlySystem"></select>
          </div>
          <div>
            <label for="monthlyMonth">Month</label>
            <input id="monthlyMonth" type="month"/>
          </div>
          <div>
            <button id="buildMonthly">Build Grid</button>
          </div>
          <div>
            <button id="monthlyPrint">Print/PDF</button>
          </div>
          <div>
            <button id="monthlyExport">Export CSV</button>
          </div>
          <div>
            <button id="monthlyExportExcel">Export Excel</button>
          </div>
        </div>
        <p class="note">Build a grid for the selected month. Values outside range are highlighted.</p>
      </div>
      <div class="card" id="monthlyGridCard">
        <h2 id="monthlyGridTitle">Monthly View</h2>
        <div id="monthlyGridContainer">
          <!-- monthly grid inserted here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Tab Content -->
  <div id="settings" class="tab-content">
    <div class="wrap">
      <div class="card" id="storageSettings">
        <h2>Storage</h2>
        <label for="storageMode">Mode</label>
        <select id="storageMode">
          <option value="local">Local (this device only)</option>
          <option value="firebase">Firebase (shared across users)</option>
        </select>
        <label for="namespace">Namespace (site/project name)</label>
        <input id="namespace" type="text" placeholder="daily-logs"/>
        <div id="firebaseConfigSection" style="display:none;">
          <label for="firebaseConfig">Firebase Config (JSON)</label>
          <textarea id="firebaseConfig" placeholder='{"apiKey": "...", "projectId": "...", ...}'></textarea>
          <button id="enableFirebase">Enable Firebase</button>
          <p class="note">Firestore will store settings and logs under the chosen namespace.</p>
        </div>
      </div>
      <div class="card" id="systemSettings">
        <h2>Systems / Points / Fields</h2>
        <div class="gridControls">
          <button id="addSystem">Add System</button>
          <button id="seedDefaults">Seed Defaults</button>
          <button id="exportBackup">Export Full Backup</button>
          <button id="forceReset">Force Reset (clear storage)</button>
        </div>
        <div id="systemsList">
          <!-- systems list inserted here -->
        </div>
        <h3>High/Low Ranges</h3>
        <div id="rangesList">
          <!-- ranges table inserted here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Trends Tab Content -->
  <div id="trends" class="tab-content">
    <div class="wrap">
      <div class="card" id="trendControls">
        <h2>Trend Controls</h2>
        <div class="toolbar">
          <div>
            <label for="trendSystem">System</label>
            <select id="trendSystem"></select>
          </div>
          <div>
            <label for="trendPoint">Point</label>
            <select id="trendPoint"></select>
          </div>
          <div>
            <label for="trendField">Field</label>
            <select id="trendField"></select>
          </div>
          <div>
            <label for="trendFrom">From</label>
            <input id="trendFrom" type="date"/>
          </div>
          <div>
            <label for="trendTo">To</label>
            <input id="trendTo" type="date"/>
          </div>
          <div>
            <button id="showTrend">Show Trend</button>
          </div>
        </div>
      </div>
      <div class="card" id="trendChartCard">
        <h2 id="trendTitle">Trend</h2>
        <canvas id="trendChart" height="300"></canvas>
      </div>
    </div>
  </div>

  <script>
    /*
     * Configuration and data structures
     *
     * config: {
     *   systems: {
     *     [systemName]: {
     *       points: {
     *         [pointName]: {
     *           fields: [field1, field2, ...],
     *           meterField?: name of the meter reading field (string),
     *           calcField?: name of the delta field (string),
     *           totalField?: name of the running total field (string)
     *         }
     *       }
     *     }
     *   },
     *   ranges: {
     *     "system|field": { low: number|null, high: number|null }
     *   },
     *   storage: {
     *     mode: "local" | "firebase",
     *     namespace: string,
     *     firebaseConfig: object|null
     *   }
     * }
     *
     * logs: {
     *   [date]: {
     *     [system]: {
     *       [point]: {
     *         [field]: value
     *       }
     *     }
     *   }
     * }
     */
    const DEFAULT_NAMESPACE = 'daily-logs';
    let config = null;
    let logs = {};
    let firestore = null;

    /** Load configuration from storage or initialize defaults. */
    function loadConfig() {
      const stored = localStorage.getItem('dailyLogConfig');
      if (stored) {
        try {
          config = JSON.parse(stored);
        } catch (e) {
          console.warn('Failed to parse config, resetting');
          config = null;
        }
      }
      if (!config) {
        // Initialize minimal config
        config = {
          systems: {},
          ranges: {},
          storage: { mode: 'local', namespace: DEFAULT_NAMESPACE, firebaseConfig: null }
        };
      }
    }

    /** Save configuration to localStorage and Firestore if enabled. */
    async function saveConfig() {
      localStorage.setItem('dailyLogConfig', JSON.stringify(config));
      if (config.storage.mode === 'firebase' && firestore) {
        const ns = config.storage.namespace || DEFAULT_NAMESPACE;
        await firestore.collection('config').doc(ns).set(config);
      }
    }

    /** Load logs from storage (local or Firestore) into memory. */
    async function loadLogs() {
      logs = {};
      if (config.storage.mode === 'firebase' && firestore) {
        const ns = config.storage.namespace || DEFAULT_NAMESPACE;
        const snap = await firestore.collection('logs').doc(ns).get();
        if (snap.exists) {
          logs = snap.data() || {};
        }
      } else {
        const stored = localStorage.getItem('dailyLogData');
        if (stored) {
          try { logs = JSON.parse(stored); } catch (e) { logs = {}; }
        }
      }
    }

    /** Save logs to storage. */
    async function saveLogs() {
      if (config.storage.mode === 'firebase' && firestore) {
        const ns = config.storage.namespace || DEFAULT_NAMESPACE;
        await firestore.collection('logs').doc(ns).set(logs);
      } else {
        localStorage.setItem('dailyLogData', JSON.stringify(logs));
      }
    }

    /** Initialize Firebase if config is provided. */
    function initFirebase() {
      if (!config.storage.firebaseConfig) return;
      try {
        firebase.initializeApp(config.storage.firebaseConfig);
        firestore = firebase.firestore();
      } catch (e) {
        console.error('Firebase init error', e);
      }
    }

    /** Seed default systems and points. */
    function seedDefaults() {
      // Only seed if no systems yet
      if (Object.keys(config.systems).length > 0) return;
      /*
        Define a comprehensive set of default systems.  Each system contains one
        or more points and each point defines a list of fields.  Where
        appropriate, a point may also define a meterField (the primary
        reading), a calcField (the per‑day delta) and a totalField (the
        month‑to‑date total).  These three properties enable the automatic
        makeup calculations used throughout the app.

        The following defaults were derived from the user’s specification.  If
        additional systems or points are needed later they can be added via
        the Settings tab.
      */
      // B Condensate Return – two points (East/West) with pH, hardness and conductivity
      config.systems['B Condensate Return'] = {
        points: {
          'East': { fields: ['pH','Total Hardness','Conductivity (UMHOS/CM)'] },
          'West': { fields: ['pH','Total Hardness','Conductivity (UMHOS/CM)'] }
        }
      };
      // Cooling Tower Supply Log #1 – includes meter and computed makeup
      config.systems['Cooling Tower Supply Log #1'] = {
        points: {
          'Tower 1': {
            fields: ['M','Makeup (calc)','Total Makeup (calc)','pH','ORP','Total Hardness','PTSA','Conductivity','Chemical Added','Comments'],
            meterField: 'M',
            calcField: 'Makeup (calc)',
            totalField: 'Total Makeup (calc)'
          }
        }
      };
      // Cooling Tower Supply Log #2 – same as #1 but for tower 2
      config.systems['Cooling Tower Supply Log #2'] = {
        points: {
          'Tower 2': {
            fields: ['M','Makeup (calc)','Total Makeup (calc)','pH','ORP','Total Hardness','PTSA','Conductivity','Chemical Added','Comments'],
            meterField: 'M',
            calcField: 'Makeup (calc)',
            totalField: 'Total Makeup (calc)'
          }
        }
      };
      // Central chilled water supply – single point with nitrite, TDS, etc.
      config.systems['Central Chilled Water Supply Log'] = {
        points: {
          'Supply': { fields: ['Nitrite','Total Dissolved Solids (TDS / TD)','pH','Hardness','Chemical Added','Comments'] }
        }
      };
      // Central hot water supply – similar fields as chilled water
      config.systems['Central Hot Water Supply Log'] = {
        points: {
          'Supply': { fields: ['Nitrite','Total Dissolved Solids (TDS / TD)','pH','Hardness','Chemical Added','Comments'] }
        }
      };
      // Boiler log – J Laundry – gallons used as meter with makeup logic
      config.systems['Boiler Log – J Laundry'] = {
        points: {
          'Laundry': {
            fields: [
              'Gallons','Makeup (calc)','Total Makeup (calc)',
              'Manual Blowdown','Continuous Blowdown (CBD)','Softener #','Chlorine (Cl)',
              'Total Hardness (TH)','Alkalinity (ALK)','pH','Sulfite (SO3)','Conductivity',
              'Phosphate (PO4)','DEHA','Total Hardness (return or feedwater)','Comments'
            ],
            meterField: 'Gallons',
            calcField: 'Makeup (calc)',
            totalField: 'Total Makeup (calc)'
          }
        }
      };
      // Boiler log – J2 Food Factory – two boilers, each with same fields as laundry
      config.systems['Boiler Log – J2 Food Factory'] = {
        points: {
          'Boiler 1': {
            fields: [
              'Gallons','Makeup (calc)','Total Makeup (calc)',
              'Manual Blowdown','Continuous Blowdown (CBD)','Softener #','Chlorine (Cl)',
              'Total Hardness (TH)','Alkalinity (ALK)','pH','Sulfite (SO3)','Conductivity',
              'Phosphate (PO4)','DEHA','Total Hardness (return or feedwater)','Comments'
            ],
            meterField: 'Gallons',
            calcField: 'Makeup (calc)',
            totalField: 'Total Makeup (calc)'
          },
          'Boiler 2': {
            fields: [
              'Gallons','Makeup (calc)','Total Makeup (calc)',
              'Manual Blowdown','Continuous Blowdown (CBD)','Softener #','Chlorine (Cl)',
              'Total Hardness (TH)','Alkalinity (ALK)','pH','Sulfite (SO3)','Conductivity',
              'Phosphate (PO4)','DEHA','Total Hardness (return or feedwater)','Comments'
            ],
            meterField: 'Gallons',
            calcField: 'Makeup (calc)',
            totalField: 'Total Makeup (calc)'
          }
        }
      };
      // J Condensate Return – simple return with pH, hardness and conductivity
      config.systems['J Condensate Return'] = {
        points: {
          'Return': { fields: ['pH','Total Hardness (TH)','Conductivity (UMHOS/CM)'] }
        }
      };
      // Retain Gas Meter from original defaults
      config.systems['Gas Meter'] = {
        points: {
          'Gas': {
            fields: ['Reading','Usage (calc)','Total Usage (calc)'],
            meterField: 'Reading',
            calcField: 'Usage (calc)',
            totalField: 'Total Usage (calc)'
          }
        }
      };
      saveConfig();
      renderSystemOptions();
      renderSystemsList();
      renderRangesTable();
    }

    /** Render the system selector options for daily, monthly and trend views. */
    function renderSystemOptions() {
      const dailySelect = document.getElementById('dailySystem');
      const monthlySelect = document.getElementById('monthlySystem');
      const trendSelect = document.getElementById('trendSystem');
      [dailySelect, monthlySelect, trendSelect].forEach(sel => {
        sel.innerHTML = '';
        const defOpt = document.createElement('option');
        defOpt.textContent = '-- Select System --';
        defOpt.value = '';
        sel.appendChild(defOpt);
        Object.keys(config.systems).forEach(sys => {
          const opt = document.createElement('option');
          opt.value = sys;
          opt.textContent = sys;
          sel.appendChild(opt);
        });
      });
    }

    /**
     * Render list of systems, points and fields in the Settings tab.  This
     * version provides buttons to add or delete systems, points and fields.
     * Systems are shown as cards with their points nested underneath.  Each
     * system has a "Delete" button and an "Add Point" button.  Each point
     * lists its fields and provides an "Add Field" button plus delete
     * buttons for individual fields and the point itself.  Deleting a
     * system or point will also remove any associated log entries.
     */
    function renderSystemsList() {
      const container = document.getElementById('systemsList');
      container.innerHTML = '';
      const systems = config.systems;
      Object.entries(systems).forEach(([sysName, sysObj]) => {
        const sysDiv = document.createElement('div');
        sysDiv.className = 'card';
        // System header with name and delete button
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        const title = document.createElement('h3');
        title.textContent = sysName;
        header.appendChild(title);
        const sysBtns = document.createElement('div');
        const delSysBtn = document.createElement('button');
        delSysBtn.textContent = 'Delete';
        delSysBtn.className = 'small-btn';
        delSysBtn.addEventListener('click', () => {
          if (!confirm(`Delete system "${sysName}" and all its data?`)) return;
          // Remove logs for this system across all dates
          Object.keys(logs).forEach(date => {
            if (logs[date][sysName]) delete logs[date][sysName];
          });
          delete config.systems[sysName];
          saveConfig();
          saveLogs();
          renderSystemOptions();
          renderSystemsList();
          renderRangesTable();
          buildDailyGrid();
          buildMonthlyGrid();
        });
        sysBtns.appendChild(delSysBtn);
        header.appendChild(sysBtns);
        sysDiv.appendChild(header);
        // Points list
        Object.entries(sysObj.points).forEach(([ptName, ptObj]) => {
          const ptDiv = document.createElement('div');
          ptDiv.style.marginBottom = '8px';
          // Point header with name and delete button
          const ptHeader = document.createElement('div');
          ptHeader.style.display = 'flex';
          ptHeader.style.justifyContent = 'space-between';
          ptHeader.style.alignItems = 'center';
          const ptTitle = document.createElement('strong');
          ptTitle.textContent = ptName;
          ptHeader.appendChild(ptTitle);
          const ptBtns = document.createElement('div');
          const delPtBtn = document.createElement('button');
          delPtBtn.textContent = 'Delete';
          delPtBtn.className = 'small-btn';
          delPtBtn.addEventListener('click', () => {
            if (!confirm(`Delete point "${ptName}" from system "${sysName}"?`)) return;
            // Remove logs for this point
            Object.keys(logs).forEach(date => {
              if (logs[date][sysName] && logs[date][sysName][ptName]) {
                delete logs[date][sysName][ptName];
              }
            });
            delete config.systems[sysName].points[ptName];
            saveConfig();
            saveLogs();
            renderSystemOptions();
            renderSystemsList();
            renderRangesTable();
            buildDailyGrid();
            buildMonthlyGrid();
          });
          ptBtns.appendChild(delPtBtn);
          ptHeader.appendChild(ptBtns);
          ptDiv.appendChild(ptHeader);
          // Fields list
          const fieldsUl = document.createElement('ul');
          fieldsUl.style.listStyle = 'disc';
          fieldsUl.style.paddingLeft = '20px';
          ptObj.fields.forEach((fieldName, idx) => {
            const li = document.createElement('li');
            // Label text
            const span = document.createElement('span');
            span.textContent = fieldName;
            li.appendChild(span);
            // Delete field button (only for non‑calc fields)
            const delFldBtn = document.createElement('button');
            delFldBtn.textContent = '×';
            delFldBtn.title = 'Delete field';
            delFldBtn.className = 'small-btn';
            delFldBtn.style.marginLeft = '6px';
            delFldBtn.addEventListener('click', () => {
              if (!confirm(`Delete field "${fieldName}" from point "${ptName}"?`)) return;
              // Remove from fields array
              const idx = ptObj.fields.indexOf(fieldName);
              if (idx >= 0) ptObj.fields.splice(idx, 1);
              // If deleting the meter/calculated fields, clear definitions
              if (ptObj.meterField === fieldName) {
                delete ptObj.meterField;
                delete ptObj.calcField;
                delete ptObj.totalField;
              }
              // Remove from logs
              Object.keys(logs).forEach(date => {
                if (logs[date]?.[sysName]?.[ptName]?.hasOwnProperty(fieldName)) {
                  delete logs[date][sysName][ptName][fieldName];
                }
              });
              saveConfig();
              saveLogs();
              renderRangesTable();
              renderSystemsList();
              buildDailyGrid();
              buildMonthlyGrid();
            });
            // Only append delete button for user‑defined (non calc) fields
            const isCalc = fieldName.toLowerCase().includes('(calc)');
            if (!isCalc) li.appendChild(delFldBtn);
            fieldsUl.appendChild(li);
          });
          ptDiv.appendChild(fieldsUl);
          // Add field button
          const addFieldBtn = document.createElement('button');
          addFieldBtn.textContent = 'Add Field';
          addFieldBtn.className = 'small-btn';
          addFieldBtn.addEventListener('click', () => {
            const fname = prompt(`Enter new field name for point "${ptName}":`);
            if (!fname) return;
            if (ptObj.fields.includes(fname)) {
              alert('Field already exists'); return;
            }
            ptObj.fields.push(fname);
            saveConfig();
            renderRangesTable();
            renderSystemsList();
            buildDailyGrid();
            buildMonthlyGrid();
          });
          ptDiv.appendChild(addFieldBtn);
          sysDiv.appendChild(ptDiv);
        });
        // Add point button
        const addPtBtn = document.createElement('button');
        addPtBtn.textContent = 'Add Point';
        addPtBtn.className = 'small-btn';
        addPtBtn.addEventListener('click', () => {
          const pn = prompt(`Enter new point name for system "${sysName}":`);
          if (!pn) return;
          if (config.systems[sysName].points[pn]) {
            alert('Point already exists'); return;
          }
          config.systems[sysName].points[pn] = { fields: [] };
          saveConfig();
          renderSystemOptions();
          renderSystemsList();
          renderRangesTable();
          buildDailyGrid();
          buildMonthlyGrid();
        });
        sysDiv.appendChild(addPtBtn);
        container.appendChild(sysDiv);
      });
    }

    /** Render ranges table for editing high/low values. */
    function renderRangesTable() {
      const container = document.getElementById('rangesList');
      container.innerHTML = '';
      // Build table with system, field, low, high
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const thr = document.createElement('tr');
      ['System','Field','Low','High'].forEach(txt => {
        const th = document.createElement('th'); th.textContent = txt; thr.appendChild(th);
      });
      thead.appendChild(thr);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      Object.entries(config.systems).forEach(([sysName, sysObj]) => {
        const fieldsSet = new Set();
        Object.values(sysObj.points).forEach(pt => pt.fields.forEach(f => fieldsSet.add(f)));
        fieldsSet.forEach(field => {
          // Only show editable ranges for non‑calc fields (skip "Makeup (calc)", "Total", etc.)
          const isCalc = field.toLowerCase().includes('(calc)');
          const tr = document.createElement('tr');
          const sysTd = document.createElement('td'); sysTd.textContent = sysName; tr.appendChild(sysTd);
          const fieldTd = document.createElement('td'); fieldTd.textContent = field; tr.appendChild(fieldTd);
          const lowTd = document.createElement('td');
          const lowInput = document.createElement('input'); lowInput.type = 'number'; lowInput.step = 'any'; lowInput.style.width = '80px';
          const key = `${sysName}|${field}`;
          const range = config.ranges[key] || { low: '', high: '' };
          lowInput.value = range.low ?? '';
          lowInput.disabled = isCalc;
          lowTd.appendChild(lowInput);
          tr.appendChild(lowTd);
          const highTd = document.createElement('td');
          const highInput = document.createElement('input'); highInput.type = 'number'; highInput.step = 'any'; highInput.style.width = '80px';
          highInput.value = range.high ?? '';
          highInput.disabled = isCalc;
          highTd.appendChild(highInput);
          tr.appendChild(highTd);
          // Save on change
          function saveRange() {
            if (!config.ranges[key]) config.ranges[key] = { low:null, high:null };
            const lVal = lowInput.value !== '' ? parseFloat(lowInput.value) : null;
            const hVal = highInput.value !== '' ? parseFloat(highInput.value) : null;
            config.ranges[key].low = lVal;
            config.ranges[key].high = hVal;
            saveConfig();
            // Recalculate highlights in current views
            buildDailyGrid();
            buildMonthlyGrid();
          }
          lowInput.addEventListener('change', saveRange);
          highInput.addEventListener('change', saveRange);
          tbody.appendChild(tr);
        });
      });
      table.appendChild(tbody);
      container.appendChild(table);
    }

    /** Build the daily grid for the selected system/date. */
    function buildDailyGrid() {
      const sysName = document.getElementById('dailySystem').value;
      const date = document.getElementById('dailyDate').value;
      const container = document.getElementById('dailyGridContainer');
      const titleEl = document.getElementById('dailyGridTitle');
      container.innerHTML = '';
      if (!sysName || !date) {
        titleEl.textContent = 'Daily View';
        return;
      }
      titleEl.textContent = `${sysName} – ${date}`;
      const sys = config.systems[sysName];
      if (!sys) return;
      // Ensure logs object exists for this date and system
      if (!logs[date]) logs[date] = {};
      if (!logs[date][sysName]) logs[date][sysName] = {};
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      const corner = document.createElement('th');
      corner.className = 'sticky-col';
      corner.textContent = 'Point / Field';
      headerRow.appendChild(corner);
      // Determine whether to build a vertical or horizontal layout.  On small
      // screens or when there are many fields, a vertical layout is easier
      // to use on mobile devices.  We consider a layout vertical when
      // the viewport width is <= 768px or the first point has more than 6
      // fields.
      const firstPoint = Object.values(sys.points)[0];
      const numPoints = Object.keys(sys.points).length;
      const verticalLayout = window.innerWidth <= 768 || firstPoint.fields.length > 6 || numPoints > 1;
      if (verticalLayout) {
        container.innerHTML = '';
        // Build a card for each point with fields listed vertically
        Object.entries(sys.points).forEach(([ptName, ptObj]) => {
          const card = document.createElement('div');
          card.className = 'card';
          card.style.marginBottom = '12px';
          const ptHeader = document.createElement('h3');
          ptHeader.textContent = ptName;
          card.appendChild(ptHeader);
          const vtable = document.createElement('table');
          const vtbody = document.createElement('tbody');
          // For vertical layout we keep a reference to this table for each row
          ptObj.fields.forEach((field, colIdx) => {
            const vr = document.createElement('tr');
            const thd = document.createElement('th');
            thd.textContent = field;
            thd.style.textAlign = 'left';
            thd.style.paddingRight = '8px';
            vr.appendChild(thd);
            const td = document.createElement('td');
            const isCalc = ptObj.calcField === field || ptObj.totalField === field;
            let val = '';
            if (logs[date] && logs[date][sysName] && logs[date][sysName][ptName] && logs[date][sysName][ptName][field] !== undefined) {
              val = logs[date][sysName][ptName][field];
            }
            if (isCalc) {
              td.classList.add('computed');
              td.textContent = val;
            } else {
              // Editable fields use an input element to avoid caret reset issues
              const inp = document.createElement('input');
              inp.type = 'text';
              inp.className = 'cell-input';
              // Set numeric keyboard by default, allow switch to letters for text-like fields
              const isTextField = /comments|chemical added/i.test(field);
              inp.setAttribute('inputmode', isTextField ? 'text' : 'decimal');
              inp.value = val;
              inp.addEventListener('input', () => {
                const value = inp.value;
                // Ensure nested objects exist
                if (!logs[date]) logs[date] = {};
                if (!logs[date][sysName]) logs[date][sysName] = {};
                if (!logs[date][sysName][ptName]) logs[date][sysName][ptName] = {};
                logs[date][sysName][ptName][field] = value;
                computeMakeupForPoint(date, sysName, ptName);
                saveLogs();
                // Update other fields for this point
                ptObj.fields.forEach((f) => {
                  const vVal = logs[date]?.[sysName]?.[ptName]?.[f] ?? '';
                  // Find the row element for f
                  const rows = vtbody.children;
                  for (let r = 0; r < rows.length; r++) {
                    const rowEl = rows[r];
                    const label = rowEl.children[0].textContent;
                    if (label === f) {
                      const cell = rowEl.children[1];
                      if (f !== field) {
                        if (cell.classList.contains('computed')) {
                          cell.textContent = vVal;
                        } else if (cell.firstElementChild && cell.firstElementChild.classList.contains('cell-input')) {
                          cell.firstElementChild.value = vVal;
                        } else {
                          cell.textContent = vVal;
                        }
                      }
                      applyRangeClass(cell, sysName, f, vVal);
                    }
                  }
                });
                // Apply range class to the current cell based on new value
                applyRangeClass(td, sysName, field, value);
              });
              td.appendChild(inp);
            }
            // Apply range class on initial render
            applyRangeClass(td, sysName, field, val);
            vr.appendChild(td);
            vtbody.appendChild(vr);
          });
          vtable.appendChild(vtbody);
          card.appendChild(vtable);
          container.appendChild(card);
        });
        return;
      }
      // Horizontal layout (default): build header row of fields
      firstPoint.fields.forEach(field => {
        const th = document.createElement('th'); th.textContent = field; headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      Object.entries(sys.points).forEach(([ptName, ptObj]) => {
        const row = document.createElement('tr');
        // capture a reference to this row for event handlers to update cells
        const rowRef = row;
        const th = document.createElement('th'); th.textContent = ptName; th.className = 'sticky-col'; row.appendChild(th);
        ptObj.fields.forEach(field => {
          const td = document.createElement('td');
          td.className = 'cell';
          const isCalc = ptObj.calcField === field || ptObj.totalField === field;
          let val = '';
          if (logs[date][sysName][ptName] && logs[date][sysName][ptName][field] !== undefined) {
            val = logs[date][sysName][ptName][field];
          }
          if (isCalc) {
            td.classList.add('computed');
            td.textContent = val;
          } else {
            // Use an input element for editable cells to preserve caret position
            const inp = document.createElement('input');
            inp.type = 'text';
            inp.className = 'cell-input';
            const isTextField = /comments|chemical added/i.test(field);
            inp.setAttribute('inputmode', isTextField ? 'text' : 'decimal');
            inp.value = val;
            inp.addEventListener('input', () => {
              const value = inp.value;
              if (!logs[date][sysName][ptName]) logs[date][sysName][ptName] = {};
              logs[date][sysName][ptName][field] = value;
              // Recompute deltas and totals for this point
              computeMakeupForPoint(date, sysName, ptName);
              saveLogs();
              // Update cells in the current row with the latest values.
              ptObj.fields.forEach((f, i) => {
                const targetCell = rowRef.children[i + 1];
                const v = logs[date]?.[sysName]?.[ptName]?.[f] ?? '';
                if (f !== field) {
                  // update target cell appropriately based on whether it's computed or contains input
                  if (targetCell.classList.contains('computed')) {
                    targetCell.textContent = v;
                  } else if (targetCell.firstElementChild && targetCell.firstElementChild.classList.contains('cell-input')) {
                    targetCell.firstElementChild.value = v;
                  } else {
                    targetCell.textContent = v;
                  }
                }
                applyRangeClass(targetCell, sysName, f, v);
              });
              // Apply range class on the current cell
              applyRangeClass(td, sysName, field, value);
            });
            td.appendChild(inp);
          }
          // Apply range class for initial render
          applyRangeClass(td, sysName, field, val);
          row.appendChild(td);
        });
        tbody.appendChild(row);
      });
      table.appendChild(tbody);
      container.appendChild(table);
    }

    /** Compute delta and total values for meter points. */
    function computeMakeupForPoint(date, sysName, ptName) {
      const sys = config.systems[sysName];
      if (!sys) return;
      const pt = sys.points[ptName];
      const meterField = pt.meterField;
      const calcField = pt.calcField;
      const totalField = pt.totalField;
      if (!meterField || !calcField || !totalField) return;
      // Current value (string) -> float
      const currentVal = logs[date]?.[sysName]?.[ptName]?.[meterField];
      const curr = parseFloat(currentVal);
      if (isNaN(curr)) {
        // Clear calc and total
        if (!logs[date][sysName][ptName]) logs[date][sysName][ptName] = {};
        logs[date][sysName][ptName][calcField] = '';
        logs[date][sysName][ptName][totalField] = '';
        return;
      }
      // Find previous date for same system/point
      const prevDate = findPreviousDate(date);
      let prev = null;
      if (prevDate && logs[prevDate]?.[sysName]?.[ptName]?.[meterField] !== undefined) {
        prev = parseFloat(logs[prevDate][sysName][ptName][meterField]);
        if (isNaN(prev)) prev = null;
      }
      const delta = prev !== null ? curr - prev : null;
      // Total: sum of deltas from the first day of month up to current date
      let total = 0;
      const [year, month] = date.split('-');
      const monthStart = new Date(year, month - 1, 1);
      for (let d = new Date(monthStart); d <= new Date(date); d.setDate(d.getDate() + 1)) {
        const dd = d.toISOString().slice(0,10);
        if (logs[dd]?.[sysName]?.[ptName]) {
          const v = parseFloat(logs[dd][sysName][ptName][meterField]);
          const prevD = findPreviousDate(dd);
          let pv = null;
          if (prevD && logs[prevD]?.[sysName]?.[ptName]?.[meterField] !== undefined) {
            pv = parseFloat(logs[prevD][sysName][ptName][meterField]);
            if (isNaN(pv)) pv = null;
          }
          if (pv !== null && !isNaN(v)) {
            total += (v - pv);
          }
        }
      }
      if (!logs[date][sysName][ptName]) logs[date][sysName][ptName] = {};
      logs[date][sysName][ptName][calcField] = delta !== null ? (delta >= 0 ? delta.toFixed(2) : '') : '';
      logs[date][sysName][ptName][totalField] = !isNaN(total) && total > 0 ? total.toFixed(2) : '';
    }

    /** Find the most recent previous date in logs before given date. */
    function findPreviousDate(date) {
      const dates = Object.keys(logs).filter(d => d < date).sort();
      return dates.length ? dates[dates.length - 1] : null;
    }

    /** Find the next chronological date string after the given date. */
    function findNextDate(date) {
      const d = new Date(date);
      d.setDate(d.getDate() + 1);
      return d.toISOString().slice(0,10);
    }

    /**
     * Export the current monthly view (selected system and month) to a CSV file.
     * The CSV contains columns Date, Point, Field and Value and can be opened
     * directly in Excel.  If no system is selected the function alerts the user.
     */
    function exportMonthlyCsv() {
      const sysName = document.getElementById('monthlySystem').value;
      const monthVal = document.getElementById('monthlyMonth').value;
      if (!sysName || !monthVal) {
        alert('Select a system and month first.');
        return;
      }
      const [year, month] = monthVal.split('-');
      const sysObj = config.systems[sysName];
      if (!sysObj) return;
      let csv = 'Date,Point,Field,Value\n';
      // Iterate over each day of the month
      const daysInMonth = new Date(year, month, 0).getDate();
      for (let day = 1; day <= daysInMonth; day++) {
        const dd = String(day).padStart(2, '0');
        const dateStr = `${year}-${month}-${dd}`;
        Object.entries(sysObj.points).forEach(([ptName, ptObj]) => {
          ptObj.fields.forEach(field => {
            const val = logs[dateStr]?.[sysName]?.[ptName]?.[field] ?? '';
            // Escape quotes
            const safeVal = String(val).replace(/"/g, '""');
            csv += `${dateStr},${ptName},"${field}","${safeVal}"\n`;
          });
        });
      }
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      // File name includes system and month for clarity
      a.download = `${sysName.replace(/\s+/g, '_')}_${year}-${month}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /**
     * Export the current monthly view (selected system and month) to an Excel
     * file (.xlsx).  Uses SheetJS library loaded in the page.  The data
     * structure is the same as the CSV export: each row contains Date,
     * Point, Field and Value.  The resulting file opens directly in
     * Microsoft Excel or other spreadsheet programs.
     */
    function exportMonthlyExcel() {
      const sysName = document.getElementById('monthlySystem').value;
      const monthVal = document.getElementById('monthlyMonth').value;
      if (!sysName || !monthVal) {
        alert('Select a system and month first.');
        return;
      }
      const [year, month] = monthVal.split('-');
      const sysObj = config.systems[sysName];
      if (!sysObj) return;
      // Build array of objects for SheetJS
      const rows = [];
      const daysInMonth = new Date(year, month, 0).getDate();
      for (let day = 1; day <= daysInMonth; day++) {
        const dd = String(day).padStart(2, '0');
        const dateStr = `${year}-${month}-${dd}`;
        Object.entries(sysObj.points).forEach(([ptName, ptObj]) => {
          ptObj.fields.forEach(field => {
            const val = logs[dateStr]?.[sysName]?.[ptName]?.[field] ?? '';
            rows.push({ Date: dateStr, Point: ptName, Field: field, Value: val });
          });
        });
      }
      // Create workbook and worksheet
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.json_to_sheet(rows, { header: ['Date','Point','Field','Value'] });
      XLSX.utils.book_append_sheet(wb, ws, 'Data');
      const filename = `${sysName.replace(/\s+/g, '_')}_${year}-${month}.xlsx`;
      XLSX.writeFile(wb, filename);
    }

    /**
     * Recompute makeup (delta and total) values for all days of a given month
     * for the specified system and point.  This is used when the user edits
     * a meter reading in the monthly view so that subsequent days are
     * recalculated correctly.  The month parameter should be a number
     * 1–12 (as returned by Date.getMonth()+1).  The year is full year.
     */
    function recomputeMakeupForMonth(sysName, ptName, year, month) {
      const daysInMonth = new Date(year, month, 0).getDate();
      const mm = String(month).padStart(2,'0');
      for (let day = 1; day <= daysInMonth; day++) {
        const dd = String(day).padStart(2,'0');
        const dateStr = `${year}-${mm}-${dd}`;
        computeMakeupForPoint(dateStr, sysName, ptName);
      }
    }

    /** Apply high/low range classes to cell. */
    function applyRangeClass(cell, system, field, value) {
      cell.classList.remove('low-cell','high-cell','ok-cell');
      const key = `${system}|${field}`;
      const range = config.ranges[key];
      const num = parseFloat(value);
      if (!range || isNaN(num)) {
        cell.classList.add('ok-cell');
        return;
      }
      const { low, high } = range;
      if (low !== null && num < low) {
        cell.classList.add('low-cell');
      } else if (high !== null && num > high) {
        cell.classList.add('high-cell');
      } else {
        cell.classList.add('ok-cell');
      }
    }

    /** Build the monthly grid when requested. */
    function buildMonthlyGrid() {
      const sysName = document.getElementById('monthlySystem').value;
      const monthStr = document.getElementById('monthlyMonth').value;
      const container = document.getElementById('monthlyGridContainer');
      const titleEl = document.getElementById('monthlyGridTitle');
      container.innerHTML = '';
      if (!sysName || !monthStr) {
        titleEl.textContent = 'Monthly View';
        return;
      }
      const [year, month] = monthStr.split('-');
      const monthStart = new Date(year, month - 1, 1);
      const monthEnd = new Date(year, month, 0);
      const daysInMonth = monthEnd.getDate();
      titleEl.textContent = `${sysName} – ${monthStr}`;
      const sys = config.systems[sysName];
      if (!sys) return;
      // Build table with days across columns
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const hr = document.createElement('tr');
      const corner = document.createElement('th'); corner.textContent = 'Point / Field'; corner.className = 'sticky-col'; hr.appendChild(corner);
      for (let d = 1; d <= daysInMonth; d++) {
        const th = document.createElement('th'); th.textContent = d; hr.appendChild(th);
      }
      thead.appendChild(hr);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      Object.entries(sys.points).forEach(([ptName, ptObj]) => {
        ptObj.fields.forEach((field, fieldIdx) => {
          const tr = document.createElement('tr');
          const th = document.createElement('th'); th.className = 'sticky-col';
          if (fieldIdx === 0) {
            th.textContent = ptName;
            th.rowSpan = ptObj.fields.length;
          }
          tr.appendChild(th);
          const fieldCell = document.createElement('th');
          fieldCell.textContent = field;
          fieldCell.className = 'sticky-col';
          tr.appendChild(fieldCell);
          for (let day = 1; day <= daysInMonth; day++) {
            const dateObj = new Date(year, month - 1, day);
            const date = dateObj.toISOString().slice(0,10);
            const td = document.createElement('td');
            td.className = 'cell';
            let val = '';
            if (logs[date]?.[sysName]?.[ptName]?.[field] !== undefined) {
              val = logs[date][sysName][ptName][field];
            }
            const isCalc = ptObj.calcField === field || ptObj.totalField === field;
            if (isCalc) {
              td.classList.add('computed');
              td.textContent = val;
            } else {
              const inp = document.createElement('input');
              inp.type = 'text';
              inp.className = 'cell-input';
              // Use numeric keyboard by default, allow switch to letters
              const isTextField = /comments|chemical added/i.test(field);
              inp.setAttribute('inputmode', isTextField ? 'text' : 'decimal');
              inp.value = val;
              // Use change event to avoid re-rendering on every keystroke
              inp.addEventListener('change', () => {
                const value = inp.value;
                // Ensure nested objects exist
                if (!logs[date]) logs[date] = {};
                if (!logs[date][sysName]) logs[date][sysName] = {};
                if (!logs[date][sysName][ptName]) logs[date][sysName][ptName] = {};
                logs[date][sysName][ptName][field] = value;
                // If the edited field is the meter field, recompute deltas for the entire month
                if (ptObj.meterField === field) {
                  // Determine month boundaries
                  const y = parseInt(year,10);
                  const m = parseInt(month,10);
                  recomputeMakeupForMonth(sysName, ptName, y, m);
                } else {
                  // Otherwise, just recompute for this date and the following date (to update totals)
                  computeMakeupForPoint(date, sysName, ptName);
                  // compute next day to update delta that depends on this day
                  const nextDate = findNextDate(date);
                  if (nextDate) computeMakeupForPoint(nextDate, sysName, ptName);
                }
                saveLogs();
                // Rebuild monthly grid to reflect changes and recalculate highlighting
                buildMonthlyGrid();
              });
              td.appendChild(inp);
            }
            applyRangeClass(td, sysName, field, val);
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        });
      });
      table.appendChild(tbody);
      container.appendChild(table);
    }

    /** Show trend chart for selected system, point, field, and date range. */
    function showTrend() {
      const sys = document.getElementById('trendSystem').value;
      const pt = document.getElementById('trendPoint').value;
      const field = document.getElementById('trendField').value;
      const from = document.getElementById('trendFrom').value;
      const to = document.getElementById('trendTo').value;
      const titleEl = document.getElementById('trendTitle');
      titleEl.textContent = `${sys} – ${pt} – ${field}`;
      const labels = [];
      const dataPoints = [];
      if (!sys || !pt || !field) return;
      // Collect logs within range
      const fromDate = from || '0000-00-00';
      const toDate = to || '9999-12-31';
      const dates = Object.keys(logs).filter(d => d >= fromDate && d <= toDate).sort();
      dates.forEach(d => {
        const val = logs[d]?.[sys]?.[pt]?.[field];
        const num = parseFloat(val);
        if (!isNaN(num)) {
          labels.push(d);
          dataPoints.push(num);
        }
      });
      const ctx = document.getElementById('trendChart').getContext('2d');
      // Destroy previous chart if exists
      if (window.trendChartInstance) {
        window.trendChartInstance.destroy();
      }
      window.trendChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{ label: field, data: dataPoints, borderColor: '#8ab4f8', fill: false }]
        },
        options: {
          responsive: true,
          scales: {
            x: { title: { display: true, text: 'Date' } },
            y: { title: { display: true, text: field }, beginAtZero: false }
          }
        }
      });
    }

    /** Event listeners and initialization */
    function initEvents() {
      // Tab switching
      document.querySelectorAll('nav.tabs .tab').forEach(btn => {
        btn.addEventListener('click', () => {
          const target = btn.dataset.target;
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
          btn.classList.add('active');
          document.getElementById(target).classList.add('active');
          // Refresh appropriate view
          if (target === 'monthly') {
            renderSystemOptions();
          } else if (target === 'settings') {
            // ensure ranges list updated
            renderRangesTable();
          } else if (target === 'trends') {
            renderSystemOptions();
          }
        });
      });
      // Date navigation
      document.getElementById('prevDay').addEventListener('click', () => {
        const dateInput = document.getElementById('dailyDate');
        if (!dateInput.value) return;
        const d = new Date(dateInput.value);
        d.setDate(d.getDate() - 1);
        dateInput.valueAsDate = d;
        buildDailyGrid();
      });
      document.getElementById('nextDay').addEventListener('click', () => {
        const dateInput = document.getElementById('dailyDate');
        if (!dateInput.value) return;
        const d = new Date(dateInput.value);
        d.setDate(d.getDate() + 1);
        dateInput.valueAsDate = d;
        buildDailyGrid();
      });
      document.getElementById('dailyDate').addEventListener('change', buildDailyGrid);
      document.getElementById('dailySystem').addEventListener('change', buildDailyGrid);
      document.getElementById('monthlySystem').addEventListener('change', buildMonthlyGrid);
      document.getElementById('monthlyMonth').addEventListener('change', buildMonthlyGrid);
      document.getElementById('buildMonthly').addEventListener('click', buildMonthlyGrid);

      // Print the monthly grid (browser's print dialog, which can export to PDF)
      document.getElementById('monthlyPrint').addEventListener('click', () => {
        // Show only the monthly grid during print by adding a print class
        window.print();
      });
      // Export the current monthly grid as a CSV file for Excel
      document.getElementById('monthlyExport').addEventListener('click', () => {
        exportMonthlyCsv();
      });
      // Export to Excel using SheetJS
      document.getElementById('monthlyExportExcel').addEventListener('click', () => {
        exportMonthlyExcel();
      });
      // Storage mode
      document.getElementById('storageMode').addEventListener('change', (e) => {
        config.storage.mode = e.target.value;
        if (config.storage.mode === 'firebase') {
          document.getElementById('firebaseConfigSection').style.display = 'block';
        } else {
          document.getElementById('firebaseConfigSection').style.display = 'none';
        }
        saveConfig();
      });
      // Namespace
      document.getElementById('namespace').addEventListener('change', (e) => {
        config.storage.namespace = e.target.value;
        saveConfig();
      });
      // Enable Firebase
      document.getElementById('enableFirebase').addEventListener('click', async () => {
        let cfg;
        try {
          cfg = JSON.parse(document.getElementById('firebaseConfig').value);
        } catch (e) {
          alert('Invalid Firebase config JSON');
          return;
        }
        config.storage.firebaseConfig = cfg;
        initFirebase();
        await saveConfig();
        await loadLogs();
        buildDailyGrid();
        buildMonthlyGrid();
        alert('Firebase enabled');
      });
      // Add system
      document.getElementById('addSystem').addEventListener('click', () => {
        const name = prompt('Enter system name:');
        if (!name) return;
        if (config.systems[name]) { alert('System already exists'); return; }
        config.systems[name] = { points: {} };
        saveConfig();
        renderSystemOptions();
        renderSystemsList();
        renderRangesTable();
      });
      // Seed defaults
      document.getElementById('seedDefaults').addEventListener('click', () => {
        if (!confirm('Seed default systems? This will not overwrite existing systems.')) return;
        seedDefaults();
      });
      // Export backup
      document.getElementById('exportBackup').addEventListener('click', () => {
        const backup = { config, logs };
        const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'daily_logs_backup.json';
        a.click();
        URL.revokeObjectURL(url);
      });
      // Force reset
      document.getElementById('forceReset').addEventListener('click', () => {
        if (!confirm('This will clear ALL local data (config and logs) and reload the page. Continue?')) return;
        localStorage.removeItem('dailyLogConfig');
        localStorage.removeItem('dailyLogData');
        location.reload();
      });
      // Trend controls
      document.getElementById('trendSystem').addEventListener('change', () => {
        const sys = document.getElementById('trendSystem').value;
        const ptSelect = document.getElementById('trendPoint');
        ptSelect.innerHTML = '';
        const fieldSelect = document.getElementById('trendField');
        fieldSelect.innerHTML = '';
        if (!sys) return;
        const sysObj = config.systems[sys];
        Object.keys(sysObj.points).forEach(pt => {
          const opt = document.createElement('option'); opt.value = pt; opt.textContent = pt; ptSelect.appendChild(opt);
        });
        // Trigger point change to populate fields
        ptSelect.dispatchEvent(new Event('change'));
      });
      document.getElementById('trendPoint').addEventListener('change', () => {
        const sys = document.getElementById('trendSystem').value;
        const pt = document.getElementById('trendPoint').value;
        const fieldSelect = document.getElementById('trendField');
        fieldSelect.innerHTML = '';
        if (!sys || !pt) return;
        const fields = config.systems[sys].points[pt].fields;
        fields.forEach(f => {
          // Skip calc totals for trending? trending should include them too.
          const opt = document.createElement('option'); opt.value = f; opt.textContent = f; fieldSelect.appendChild(opt);
        });
      });
      document.getElementById('showTrend').addEventListener('click', showTrend);
    }

    /** Initialize the application on first load. */
    async function init() {
      loadConfig();
      // Display firebase config if needed
      if (config.storage.mode === 'firebase') {
        document.getElementById('firebaseConfigSection').style.display = 'block';
      }
      document.getElementById('storageMode').value = config.storage.mode;
      document.getElementById('namespace').value = config.storage.namespace || DEFAULT_NAMESPACE;
      if (config.storage.firebaseConfig) {
        document.getElementById('firebaseConfig').value = JSON.stringify(config.storage.firebaseConfig);
        initFirebase();
      }
      await loadLogs();
      // Seed defaults if no systems
      if (Object.keys(config.systems).length === 0) {
        seedDefaults();
      }
      renderSystemOptions();
      renderSystemsList();
      renderRangesTable();
      initEvents();
      // Preselect today's date
      const today = new Date().toISOString().slice(0,10);
      document.getElementById('dailyDate').value = today;
      // Preselect current month in monthly view (YYYY-MM)
      const currentMonth = today.slice(0,7);
      const monthlyMonthInput = document.getElementById('monthlyMonth');
      if (monthlyMonthInput) monthlyMonthInput.value = currentMonth;
      document.getElementById('trendFrom').value = today;
      document.getElementById('trendTo').value = today;
      buildDailyGrid();
    }
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
