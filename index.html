<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Daily Test Log</title>
  <!-- Inline styles replicate the look and feel of the original app -->
  <style>
    :root {
      --bg: #0f1320;
      --card: #161a2b;
      --ink: #e8eaf6;
      --muted: #a6accd;
      --accent: #8ab4f8;
      --border: #2a3152;
      --danger: #ff6b6b;
      --good: #4caf50;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto;
      overflow-y: scroll;
    }
    header {
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    header h1 {
      font-size: 18px;
      margin: 0;
    }
    nav.tabs {
      display: flex;
      gap: 8px;
      padding: 8px;
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
    }
    .tab {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0e1221;
      color: var(--ink);
      cursor: pointer;
    }
    .tab.active {
      background: #1a2040;
      border-color: #3a4370;
    }
    .tab-content {
      display: none;
      padding: 12px;
    }
    .tab-content.active { display: block; }
    .wrap {
      max-width: 1300px;
      margin: 0 auto;
      padding: 12px;
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 12px;
    }
    @media (max-width:900px) { .wrap { grid-template-columns: 1fr; } }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }
    .card h2 {
      font-size: 16px;
      margin: 0 0 8px;
    }
    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 10px 0 6px;
    }
    input, select, button, textarea {
      width: 100%;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0e1221;
      color: var(--ink);
    }
    button { cursor: pointer; }
    textarea { min-height: 120px; }
    option { color: #000; }
    .toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: end;
    }
    .toolbar > div { flex: 1; min-width: 160px; }
    .note { font-size: 12px; color: var(--muted); }
    .gridControls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      margin: 6px 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background: #0d1120;
      border: 1px solid var(--border);
      font-size: 13px;
    }
    th, td {
      border: 1px solid var(--border);
      padding: 6px 8px;
      text-align: center;
    }
    th {
      background: #11162a;
      color: #c7ceea;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .sticky-col {
      position: sticky;
      left: 0;
      background: #10162b;
      z-index: 2;
    }
    .cell { min-width: 64px; }
    .cell-input {
      width: 100%;
      background: transparent;
      border: none;
      outline: none;
      color: inherit;
      padding: 0;
      margin: 0;
      text-align: center;
      font-size: 16px;
    }
    .cell:focus { box-shadow: 0 0 0 2px var(--accent) inset; }
    .low-cell { background: rgba(76, 175, 80, 0.2); }
    .high-cell { background: rgba(255, 107, 107, 0.2); }
    .ok-cell { background: transparent; }
    .computed { user-select: none; }
    @media print {
      body { background: #fff; color: #000; }
      header, .no-print { display: none !important; }
      .wrap { grid-template-columns: 1fr; }
      .card { border: none; padding: 0; }
      th, td { border: 1px solid #777; color: #000; }
      th { background: #eee; color: #000; }
      .sticky-col { position: static; background: #fff; }
    }
    .small-btn {
      font-size: 12px;
      padding: 2px 6px;
      margin-left: 4px;
      background: var(--border);
      color: var(--ink);
      border: 1px solid var(--border);
      border-radius: 4px;
    }
    .small-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }
  </style>
  <!-- External libraries: Supabase for backend, Chart.js for trends, SheetJS for exports -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.17.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <header>
    <h1>Daily Test Log</h1>
    <p style="font-size:12px;">Offline capable. Use Settings to configure storage and systems.</p>
  </header>
  <nav class="tabs">
    <button class="tab active" data-target="daily">Daily</button>
    <button class="tab" data-target="monthly">Monthly</button>
    <button class="tab" data-target="settings">Settings</button>
    <button class="tab" data-target="trends">Trends</button>
  </nav>
  <div class="wrap">
    <!-- Daily Tab Content -->
    <div id="daily" class="tab-content active">
      <div class="card">
        <h2>Controls</h2>
        <div class="gridControls">
          <div>
            <label for="dailySystem">System</label>
            <select id="dailySystem"></select>
          </div>
          <div>
            <label for="dailyDate">Date</label>
            <input type="date" id="dailyDate">
          </div>
          <div style="display:flex; gap:4px;">
            <button id="prevDay" style="flex:1;">◀ Prev</button>
            <button id="nextDay" style="flex:1;">Next ▶</button>
          </div>
        </div>
      </div>
      <div class="card" id="dailyGridContainer">
        <h2 id="dailyGridTitle">Daily View</h2>
      </div>
    </div>
    <!-- Monthly Tab Content -->
    <div id="monthly" class="tab-content">
      <div class="card">
        <h2>Monthly Controls</h2>
        <div class="gridControls">
          <div>
            <label for="monthlySystem">System</label>
            <select id="monthlySystem"></select>
          </div>
          <div>
            <label for="monthlyMonth">Month</label>
            <input type="month" id="monthlyMonth">
          </div>
        </div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;">
          <button id="buildMonthly">Build Grid</button>
          <button id="monthlyPrint">Print/PDF</button>
          <button id="monthlyExport">Export CSV</button>
          <button id="monthlyExportExcel">Export Excel</button>
        </div>
        <p class="note">Build a grid for the selected month. Values outside range are highlighted.</p>
      </div>
      <div class="card" id="monthlyGridContainer">
        <h2 id="monthlyGridTitle">Monthly View</h2>
      </div>
    </div>
    <!-- Settings Tab Content -->
    <div id="settings" class="tab-content">
      <div class="card">
        <h2>Storage</h2>
        <label for="storageMode">Mode</label>
        <select id="storageMode">
          <option value="local">Local (this device only)</option>
          <option value="firebase">Firebase (shared across users)</option>
          <option value="supabase">Supabase (shared across users)</option>
        </select>
        <label for="namespace">Namespace (site/project name)</label>
        <input type="text" id="namespace">
        <div id="firebaseConfigSection" style="display:none;">
          <label for="firebaseConfig">Firebase Config (JSON)</label>
          <textarea id="firebaseConfig"></textarea>
          <button id="enableFirebase">Enable Firebase</button>
          <p class="note">Firestore will store settings and logs under the chosen namespace.</p>
        </div>
      </div>
      <div class="card">
        <h2>Systems / Points / Fields</h2>
        <div style="margin-bottom:8px;">
          <button id="addSystem" class="small-btn">Add System</button>
          <button id="seedDefaults" class="small-btn">Seed Defaults</button>
          <button id="exportBackup" class="small-btn">Export Full Backup</button>
          <button id="forceReset" class="small-btn">Force Reset (clear storage)</button>
        </div>
        <div id="systemsList"></div>
      </div>
      <div class="card">
        <h2>High/Low Ranges</h2>
        <div id="rangesList"></div>
      </div>
    </div>
    <!-- Trends Tab Content -->
    <div id="trends" class="tab-content">
      <div class="card">
        <h2>Trend Controls</h2>
        <div class="gridControls">
          <div>
            <label for="trendSystem">System</label>
            <select id="trendSystem"></select>
          </div>
          <div>
            <label for="trendPoint">Point</label>
            <select id="trendPoint"></select>
          </div>
          <div>
            <label for="trendField">Field</label>
            <select id="trendField"></select>
          </div>
          <div>
            <label for="trendFrom">From</label>
            <input type="date" id="trendFrom">
          </div>
          <div>
            <label for="trendTo">To</label>
            <input type="date" id="trendTo">
          </div>
          <button id="showTrend">Show Trend</button>
        </div>
        <h2 id="trendTitle">Trend</h2>
        <canvas id="trendChart" style="width:100%; height:300px;"></canvas>
      </div>
    </div>
  </div>
  <!-- JavaScript to handle data, rendering and interactions -->
  <script>
    // Core configuration and data structures
    const DEFAULT_NAMESPACE = 'daily-logs';
    let config = null;
    let logs = {};
    let firestore = null;
    // Supabase credentials provided by the user
    const SUPABASE_URL = 'https://hdtzibffzuesghcujjfc.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhkdHppYmZmenVlc2doY3VqamZjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUxNDAzMjUsImV4cCI6MjA3MDcxNjMyNX0.dd0BRl1D6XqvPbUIMFE-9xDr9YvDI0qyA2E5CMaq1ZI';
    let supabaseClient = null;

    // Initialize Supabase client when needed
    function initSupabase() {
      if (!supabaseClient) {
        supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      }
    }

    // Load configuration from local storage; remote config will override later if using supabase
    function loadConfig() {
      const stored = localStorage.getItem('dailyLogConfig');
      if (stored) {
        try {
          config = JSON.parse(stored);
        } catch (e) {
          console.warn('Failed to parse config, resetting');
          config = null;
        }
      }
      if (!config) {
        config = {
          systems: {},
          ranges: {},
          storage: { mode: 'local', namespace: DEFAULT_NAMESPACE, firebaseConfig: null }
        };
      }
    }

    // Save config to localStorage and optionally to Supabase or Firebase
    async function saveConfig() {
      localStorage.setItem('dailyLogConfig', JSON.stringify(config));
      // Save to Firebase if enabled
      if (config.storage.mode === 'firebase' && firestore) {
        const ns = config.storage.namespace || DEFAULT_NAMESPACE;
        await firestore.collection('config').doc(ns).set(config);
      }
      // Save to Supabase if enabled
      if (config.storage.mode === 'supabase') {
        await remoteSaveConfig();
      }
    }

    // Load logs from local storage or remote
    async function loadLogs() {
      logs = {};
      if (config.storage.mode === 'firebase' && firestore) {
        const ns = config.storage.namespace || DEFAULT_NAMESPACE;
        const snap = await firestore.collection('logs').doc(ns).get();
        if (snap.exists) {
          logs = snap.data() || {};
        }
      } else {
        const stored = localStorage.getItem('dailyLogData');
        if (stored) {
          try { logs = JSON.parse(stored); } catch (e) { logs = {}; }
        }
      }
      if (config.storage.mode === 'supabase') {
        await remoteLoadLogs();
      }
    }

    // Save logs to local storage or remote
    async function saveLogs() {
      if (config.storage.mode === 'firebase' && firestore) {
        const ns = config.storage.namespace || DEFAULT_NAMESPACE;
        await firestore.collection('logs').doc(ns).set(logs);
      } else {
        localStorage.setItem('dailyLogData', JSON.stringify(logs));
      }
      if (config.storage.mode === 'supabase') {
        await remoteSaveLogs();
      }
    }

    // Firebase initialization
    function initFirebase() {
      if (!config.storage.firebaseConfig) return;
      try {
        firebase.initializeApp(config.storage.firebaseConfig);
        firestore = firebase.firestore();
      } catch (e) {
        console.error('Firebase init error', e);
      }
    }

    // Supabase: load config from remote table (namespace column "namespace", config json in "config")
    async function remoteLoadConfig() {
      if (config.storage.mode !== 'supabase') return;
      initSupabase();
      const ns = config.storage.namespace || DEFAULT_NAMESPACE;
      try {
        const { data, error } = await supabaseClient
          .from('config')
          .select('config')
          .eq('namespace', ns)
          .single();
        if (!error && data && data.config) {
          config = data.config;
        }
      } catch (e) {
        console.warn('Supabase load config error', e);
      }
    }

    // Supabase: save config
    async function remoteSaveConfig() {
      if (config.storage.mode !== 'supabase') return;
      initSupabase();
      const ns = config.storage.namespace || DEFAULT_NAMESPACE;
      try {
        await supabaseClient
          .from('config')
          .upsert({ namespace: ns, config });
      } catch (e) {
        console.warn('Supabase save config error', e);
      }
    }

    // Supabase: load logs
    async function remoteLoadLogs() {
      if (config.storage.mode !== 'supabase') return;
      initSupabase();
      const ns = config.storage.namespace || DEFAULT_NAMESPACE;
      try {
        const { data, error } = await supabaseClient
          .from('logs')
          .select('data')
          .eq('namespace', ns)
          .single();
        if (!error && data && data.data) {
          logs = data.data;
        }
      } catch (e) {
        console.warn('Supabase load logs error', e);
      }
    }

    // Supabase: save logs
    async function remoteSaveLogs() {
      if (config.storage.mode !== 'supabase') return;
      initSupabase();
      const ns = config.storage.namespace || DEFAULT_NAMESPACE;
      try {
        await supabaseClient
          .from('logs')
          .upsert({ namespace: ns, data: logs });
      } catch (e) {
        console.warn('Supabase save logs error', e);
      }
    }

    // Default systems for seeding
    function seedDefaults() {
      if (Object.keys(config.systems).length > 0) return;
      // B Condensate Return – two points (East/West) with pH, hardness and conductivity
      config.systems['B Condensate Return'] = {
        points: {
          'East': { fields: ['pH','Total Hardness','Conductivity (UMHOS/CM)'] },
          'West': { fields: ['pH','Total Hardness','Conductivity (UMHOS/CM)'] }
        }
      };
      // Cooling Tower Supply Log #1 – includes meter and computed makeup
      config.systems['Cooling Tower Supply Log #1'] = {
        points: {
          'Tower 1': {
            fields: ['M','Makeup (calc)','Total Makeup (calc)','pH','ORP','Total Hardness','PTSA','Conductivity','Chemical Added','Comments'],
            meterField: 'M',
            calcField: 'Makeup (calc)',
            totalField: 'Total Makeup (calc)'
          }
        }
      };
      // Cooling Tower Supply Log #2 – same as #1 but for tower 2
      config.systems['Cooling Tower Supply Log #2'] = {
        points: {
          'Tower 2': {
            fields: ['M','Makeup (calc)','Total Makeup (calc)','pH','ORP','Total Hardness','PTSA','Conductivity','Chemical Added','Comments'],
            meterField: 'M',
            calcField: 'Makeup (calc)',
            totalField: 'Total Makeup (calc)'
          }
        }
      };
      // Central chilled water supply – single point
      config.systems['Central Chilled Water Supply Log'] = {
        points: {
          'Supply': { fields: ['Nitrite','Total Dissolved Solids (TDS / TD)','pH','Hardness','Chemical Added','Comments'] }
        }
      };
      // Central hot water supply
      config.systems['Central Hot Water Supply Log'] = {
        points: {
          'Supply': { fields: ['Nitrite','Total Dissolved Solids (TDS / TD)','pH','Hardness','Chemical Added','Comments'] }
        }
      };
      // Boiler log – J Laundry
      config.systems['Boiler Log – J Laundry'] = {
        points: {
          'Laundry': {
            fields: ['Gallons','Makeup (calc)','Total Makeup (calc)','Manual Blowdown','Continuous Blowdown (CBD)','Softener #','Chlorine (Cl)','Total Hardness (TH)','Alkalinity (ALK)','pH','Sulfite (SO3)','Conductivity','Phosphate (PO4)','DEHA','Total Hardness (return or feedwater)','Comments'],
            meterField: 'Gallons',
            calcField: 'Makeup (calc)',
            totalField: 'Total Makeup (calc)'
          }
        }
      };
      // Boiler log – J2 Food Factory – two boilers
      config.systems['Boiler Log – J2 Food Factory'] = {
        points: {
          'Boiler 1': {
            fields: ['Gallons','Makeup (calc)','Total Makeup (calc)','Manual Blowdown','Continuous Blowdown (CBD)','Softener #','Chlorine (Cl)','Total Hardness (TH)','Alkalinity (ALK)','pH','Sulfite (SO3)','Conductivity','Phosphate (PO4)','DEHA','Total Hardness (return or feedwater)','Comments'],
            meterField: 'Gallons',
            calcField: 'Makeup (calc)',
            totalField: 'Total Makeup (calc)'
          },
          'Boiler 2': {
            fields: ['Gallons','Makeup (calc)','Total Makeup (calc)','Manual Blowdown','Continuous Blowdown (CBD)','Softener #','Chlorine (Cl)','Total Hardness (TH)','Alkalinity (ALK)','pH','Sulfite (SO3)','Conductivity','Phosphate (PO4)','DEHA','Total Hardness (return or feedwater)','Comments'],
            meterField: 'Gallons',
            calcField: 'Makeup (calc)',
            totalField: 'Total Makeup (calc)'
          }
        }
      };
      // J Condensate Return
      config.systems['J Condensate Return'] = {
        points: {
          'Return': { fields: ['pH','Total Hardness (TH)','Conductivity (UMHOS/CM)'] }
        }
      };
      // Gas Meter
      config.systems['Gas Meter'] = {
        points: {
          'Gas': {
            fields: ['Reading','Usage (calc)','Total Usage (calc)'],
            meterField: 'Reading',
            calcField: 'Usage (calc)',
            totalField: 'Total Usage (calc)'
          }
        }
      };
      // Save and re-render UI
      saveConfig();
      renderSystemOptions();
      renderSystemsList();
      renderRangesTable();
    }

    // Render system options for daily, monthly and trends
    function renderSystemOptions() {
      const dailySelect = document.getElementById('dailySystem');
      const monthlySelect = document.getElementById('monthlySystem');
      const trendSelect = document.getElementById('trendSystem');
      [dailySelect, monthlySelect, trendSelect].forEach(sel => {
        sel.innerHTML = '';
        const defOpt = document.createElement('option');
        defOpt.textContent = '-- Select System --';
        defOpt.value = '';
        sel.appendChild(defOpt);
        Object.keys(config.systems).forEach(sys => {
          const opt = document.createElement('option');
          opt.value = sys;
          opt.textContent = sys;
          sel.appendChild(opt);
        });
      });
    }

    // Render list of systems, points and fields with add/delete/edit functionality
    function renderSystemsList() {
      const container = document.getElementById('systemsList');
      container.innerHTML = '';
      const systems = config.systems;
      Object.entries(systems).forEach(([sysName, sysObj]) => {
        const sysDiv = document.createElement('div');
        sysDiv.className = 'card';
        // System header
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        const title = document.createElement('h3');
        title.textContent = sysName;
        // Enable rename on double-click
        title.style.cursor = 'pointer';
        title.title = 'Double-click to edit system name';
        title.addEventListener('dblclick', () => {
          const newName = prompt('Edit system name:', sysName);
          if (!newName || newName === sysName) return;
          if (config.systems[newName]) {
            alert('System already exists');
            return;
          }
          // Copy system and logs
          config.systems[newName] = config.systems[sysName];
          delete config.systems[sysName];
          Object.keys(logs).forEach(date => {
            if (logs[date] && logs[date][sysName]) {
              logs[date][newName] = logs[date][sysName];
              delete logs[date][sysName];
            }
          });
          saveConfig();
          saveLogs();
          renderSystemOptions();
          renderSystemsList();
          renderRangesTable();
          buildDailyGrid();
          buildMonthlyGrid();
        });
        header.appendChild(title);
        const sysBtns = document.createElement('div');
        const delSysBtn = document.createElement('button');
        delSysBtn.textContent = 'Delete';
        delSysBtn.className = 'small-btn';
        delSysBtn.addEventListener('click', () => {
          if (!confirm(`Delete system "${sysName}" and all its data?`)) return;
          // Remove logs for this system
          Object.keys(logs).forEach(date => {
            if (logs[date] && logs[date][sysName]) delete logs[date][sysName];
          });
          delete config.systems[sysName];
          saveConfig();
          saveLogs();
          renderSystemOptions();
          renderSystemsList();
          renderRangesTable();
          buildDailyGrid();
          buildMonthlyGrid();
        });
        sysBtns.appendChild(delSysBtn);
        header.appendChild(sysBtns);
        sysDiv.appendChild(header);
        // Points list
        Object.entries(sysObj.points).forEach(([ptName, ptObj]) => {
          const ptDiv = document.createElement('div');
          ptDiv.style.marginBottom = '8px';
          // Point header
          const ptHeader = document.createElement('div');
          ptHeader.style.display = 'flex';
          ptHeader.style.justifyContent = 'space-between';
          ptHeader.style.alignItems = 'center';
          const ptTitle = document.createElement('strong');
          ptTitle.textContent = ptName;
          // Enable rename for point
          ptTitle.style.cursor = 'pointer';
          ptTitle.title = 'Double-click to edit point name';
          ptTitle.addEventListener('dblclick', () => {
            const newPtName = prompt('Edit point name:', ptName);
            if (!newPtName || newPtName === ptName) return;
            if (config.systems[sysName].points[newPtName]) {
              alert('Point already exists');
              return;
            }
            config.systems[sysName].points[newPtName] = config.systems[sysName].points[ptName];
            delete config.systems[sysName].points[ptName];
            // Update logs
            Object.keys(logs).forEach(date => {
              if (logs[date]?.[sysName]?.[ptName]) {
                logs[date][sysName][newPtName] = logs[date][sysName][ptName];
                delete logs[date][sysName][ptName];
              }
            });
            saveConfig();
            saveLogs();
            renderSystemOptions();
            renderSystemsList();
            renderRangesTable();
            buildDailyGrid();
            buildMonthlyGrid();
          });
          ptHeader.appendChild(ptTitle);
          const ptBtns = document.createElement('div');
          const delPtBtn = document.createElement('button');
          delPtBtn.textContent = 'Delete';
          delPtBtn.className = 'small-btn';
          delPtBtn.addEventListener('click', () => {
            if (!confirm(`Delete point "${ptName}" from system "${sysName}"?`)) return;
            // Remove logs for this point
            Object.keys(logs).forEach(date => {
              if (logs[date]?.[sysName]?.[ptName]) {
                delete logs[date][sysName][ptName];
              }
            });
            delete config.systems[sysName].points[ptName];
            saveConfig();
            saveLogs();
            renderSystemOptions();
            renderSystemsList();
            renderRangesTable();
            buildDailyGrid();
            buildMonthlyGrid();
          });
          ptBtns.appendChild(delPtBtn);
          ptHeader.appendChild(ptBtns);
          ptDiv.appendChild(ptHeader);
          // Fields list
          const fieldsUl = document.createElement('ul');
          fieldsUl.style.listStyle = 'disc';
          fieldsUl.style.paddingLeft = '20px';
          ptObj.fields.forEach((fieldName) => {
            const li = document.createElement('li');
            const span = document.createElement('span');
            span.textContent = fieldName;
            // Enable rename for field
            span.style.cursor = 'pointer';
            span.title = 'Double-click to edit field name';
            span.addEventListener('dblclick', () => {
              const newFieldName = prompt('Edit field name:', fieldName);
              if (!newFieldName || newFieldName === fieldName) return;
              if (ptObj.fields.includes(newFieldName)) {
                alert('Field already exists'); return;
              }
              const idx = ptObj.fields.indexOf(fieldName);
              if (idx >= 0) ptObj.fields[idx] = newFieldName;
              // Update meter/calc/total definitions
              if (ptObj.meterField === fieldName) ptObj.meterField = newFieldName;
              if (ptObj.calcField === fieldName) ptObj.calcField = newFieldName;
              if (ptObj.totalField === fieldName) ptObj.totalField = newFieldName;
              // Update logs
              Object.keys(logs).forEach(date => {
                const ptLog = logs[date]?.[sysName]?.[ptName];
                if (ptLog && Object.prototype.hasOwnProperty.call(ptLog, fieldName)) {
                  ptLog[newFieldName] = ptLog[fieldName];
                  delete ptLog[fieldName];
                }
              });
              saveConfig();
              saveLogs();
              renderRangesTable();
              renderSystemsList();
              buildDailyGrid();
              buildMonthlyGrid();
            });
            li.appendChild(span);
            // Delete field button (only for non-calc fields)
            const delFldBtn = document.createElement('button');
            delFldBtn.textContent = '×';
            delFldBtn.title = 'Delete field';
            delFldBtn.className = 'small-btn';
            delFldBtn.style.marginLeft = '6px';
            delFldBtn.addEventListener('click', () => {
              if (!confirm(`Delete field "${fieldName}" from point "${ptName}"?`)) return;
              const idx = ptObj.fields.indexOf(fieldName);
              if (idx >= 0) ptObj.fields.splice(idx, 1);
              if (ptObj.meterField === fieldName) {
                delete ptObj.meterField;
                delete ptObj.calcField;
                delete ptObj.totalField;
              }
              Object.keys(logs).forEach(date => {
                if (logs[date]?.[sysName]?.[ptName]?.hasOwnProperty(fieldName)) {
                  delete logs[date][sysName][ptName][fieldName];
                }
              });
              saveConfig();
              saveLogs();
              renderRangesTable();
              renderSystemsList();
              buildDailyGrid();
              buildMonthlyGrid();
            });
            // Show delete button only for non-calc fields
            const isCalc = fieldName.toLowerCase().includes('(calc)');
            if (!isCalc) li.appendChild(delFldBtn);
            fieldsUl.appendChild(li);
          });
          ptDiv.appendChild(fieldsUl);
          // Add field button
          const addFieldBtn = document.createElement('button');
          addFieldBtn.textContent = 'Add Field';
          addFieldBtn.className = 'small-btn';
          addFieldBtn.addEventListener('click', () => {
            const fname = prompt(`Enter new field name for point "${ptName}":`);
            if (!fname) return;
            if (ptObj.fields.includes(fname)) {
              alert('Field already exists'); return;
            }
            ptObj.fields.push(fname);
            saveConfig();
            renderRangesTable();
            renderSystemsList();
            buildDailyGrid();
            buildMonthlyGrid();
          });
          ptDiv.appendChild(addFieldBtn);
          sysDiv.appendChild(ptDiv);
        });
        // Add point button
        const addPtBtn = document.createElement('button');
        addPtBtn.textContent = 'Add Point';
        addPtBtn.className = 'small-btn';
        addPtBtn.addEventListener('click', () => {
          const pn = prompt(`Enter new point name for system "${sysName}":`);
          if (!pn) return;
          if (config.systems[sysName].points[pn]) {
            alert('Point already exists'); return;
          }
          config.systems[sysName].points[pn] = { fields: [] };
          saveConfig();
          renderSystemOptions();
          renderSystemsList();
          renderRangesTable();
          buildDailyGrid();
          buildMonthlyGrid();
        });
        sysDiv.appendChild(addPtBtn);
        container.appendChild(sysDiv);
      });
    }

    // Render ranges table for editing high/low values
    function renderRangesTable() {
      const container = document.getElementById('rangesList');
      container.innerHTML = '';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const thr = document.createElement('tr');
      ['System','Field','Low','High'].forEach(txt => {
        const th = document.createElement('th'); th.textContent = txt; thr.appendChild(th);
      });
      thead.appendChild(thr);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      Object.entries(config.systems).forEach(([sysName, sysObj]) => {
        const fieldsSet = new Set();
        Object.values(sysObj.points).forEach(pt => pt.fields.forEach(f => fieldsSet.add(f)));
        fieldsSet.forEach(field => {
          const isCalc = field.toLowerCase().includes('(calc)');
          const tr = document.createElement('tr');
          const sysTd = document.createElement('td'); sysTd.textContent = sysName; tr.appendChild(sysTd);
          const fieldTd = document.createElement('td'); fieldTd.textContent = field; tr.appendChild(fieldTd);
          const key = `${sysName}|${field}`;
          const range = config.ranges[key] || { low: '', high: '' };
          const lowTd = document.createElement('td');
          const lowInput = document.createElement('input'); lowInput.type = 'number'; lowInput.step = 'any'; lowInput.style.width = '80px';
          lowInput.value = range.low ?? '';
          lowInput.disabled = isCalc;
          lowTd.appendChild(lowInput);
          const highTd = document.createElement('td');
          const highInput = document.createElement('input'); highInput.type = 'number'; highInput.step = 'any'; highInput.style.width = '80px';
          highInput.value = range.high ?? '';
          highInput.disabled = isCalc;
          highTd.appendChild(highInput);
          function saveRange() {
            if (!config.ranges[key]) config.ranges[key] = { low:null, high:null };
            const lVal = lowInput.value !== '' ? parseFloat(lowInput.value) : null;
            const hVal = highInput.value !== '' ? parseFloat(highInput.value) : null;
            config.ranges[key].low = lVal;
            config.ranges[key].high = hVal;
            saveConfig();
            buildDailyGrid();
            buildMonthlyGrid();
          }
          lowInput.addEventListener('change', saveRange);
          highInput.addEventListener('change', saveRange);
          tr.appendChild(lowTd);
          tr.appendChild(highTd);
          tbody.appendChild(tr);
        });
      });
      table.appendChild(tbody);
      container.appendChild(table);
    }

    // Build the daily grid for selected system and date
    function buildDailyGrid() {
      const sysName = document.getElementById('dailySystem').value;
      const date = document.getElementById('dailyDate').value;
      const container = document.getElementById('dailyGridContainer');
      const titleEl = document.getElementById('dailyGridTitle');
      // Clear container
      while (container.children.length > 1) { container.removeChild(container.lastChild); }
      if (!sysName || !date) {
        titleEl.textContent = 'Daily View';
        return;
      }
      titleEl.textContent = `${sysName} – ${date}`;
      const sys = config.systems[sysName];
      if (!sys) return;
      if (!logs[date]) logs[date] = {};
      if (!logs[date][sysName]) logs[date][sysName] = {};
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      const corner = document.createElement('th');
      corner.className = 'sticky-col';
      corner.textContent = 'Point / Field';
      headerRow.appendChild(corner);
      // Determine layout (vertical or horizontal)
      const firstPoint = Object.values(sys.points)[0];
      const numPoints = Object.keys(sys.points).length;
      const verticalLayout = window.innerWidth <= 768 || firstPoint.fields.length > 6 || numPoints > 1;
      if (verticalLayout) {
        // Remove any children beyond title
        if (container.children.length > 1) {
          while (container.children.length > 1) container.removeChild(container.lastChild);
        }
        // Build vertical cards
        Object.entries(sys.points).forEach(([ptName, ptObj]) => {
          const card = document.createElement('div');
          card.className = 'card';
          card.style.marginBottom = '12px';
          const ptHeader = document.createElement('h3');
          ptHeader.textContent = ptName;
          card.appendChild(ptHeader);
          const vtable = document.createElement('table');
          const vtbody = document.createElement('tbody');
          ptObj.fields.forEach((field) => {
            const vr = document.createElement('tr');
            const thd = document.createElement('th');
            thd.textContent = field;
            thd.style.textAlign = 'left';
            thd.style.paddingRight = '8px';
            vr.appendChild(thd);
            const td = document.createElement('td');
            const isCalc = ptObj.calcField === field || ptObj.totalField === field;
            let val = '';
            if (logs[date]?.[sysName]?.[ptName]?.[field] !== undefined) {
              val = logs[date][sysName][ptName][field];
            }
            if (isCalc) {
              td.classList.add('computed');
              td.textContent = val;
            } else {
              const inp = document.createElement('input');
              inp.type = 'text';
              inp.className = 'cell-input';
              const isTextField = /comments|chemical added/i.test(field);
              inp.setAttribute('inputmode', isTextField ? 'text' : 'decimal');
              inp.value = val;
              inp.addEventListener('input', () => {
                const value = inp.value;
                if (!logs[date]) logs[date] = {};
                if (!logs[date][sysName]) logs[date][sysName] = {};
                if (!logs[date][sysName][ptName]) logs[date][sysName][ptName] = {};
                logs[date][sysName][ptName][field] = value;
                computeMakeupForPoint(date, sysName, ptName);
                saveLogs();
                // Update all cells for this point
                ptObj.fields.forEach((f) => {
                  const vVal = logs[date]?.[sysName]?.[ptName]?.[f] ?? '';
                  const rows = vtbody.children;
                  for (let r = 0; r < rows.length; r++) {
                    const rowEl = rows[r];
                    const label = rowEl.children[0].textContent;
                    if (label === f) {
                      const cell = rowEl.children[1];
                      if (f !== field) {
                        if (cell.classList.contains('computed')) {
                          cell.textContent = vVal;
                        } else if (cell.firstElementChild && cell.firstElementChild.classList.contains('cell-input')) {
                          cell.firstElementChild.value = vVal;
                        } else {
                          cell.textContent = vVal;
                        }
                      }
                      applyRangeClass(cell, sysName, f, vVal);
                    }
                  }
                });
                applyRangeClass(td, sysName, field, value);
              });
              td.appendChild(inp);
            }
            applyRangeClass(td, sysName, field, val);
            vr.appendChild(td);
            vtbody.appendChild(vr);
          });
          vtable.appendChild(vtbody);
          card.appendChild(vtable);
          container.appendChild(card);
        });
        return;
      }
      // Horizontal layout
      firstPoint.fields.forEach(field => {
        const th = document.createElement('th'); th.textContent = field; headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      Object.entries(sys.points).forEach(([ptName, ptObj]) => {
        const rowRef = { current: null }; // wrapper for closure
        ptObj.fields.forEach((field, fieldIdx) => {
          const tr = document.createElement('tr');
          if (fieldIdx === 0) {
            const thPt = document.createElement('th');
            thPt.className = 'sticky-col';
            thPt.textContent = ptName;
            thPt.rowSpan = ptObj.fields.length;
            tr.appendChild(thPt);
          }
          const fieldCell = document.createElement('th');
          fieldCell.textContent = field;
          fieldCell.className = 'sticky-col';
          tr.appendChild(fieldCell);
          for (let day = 1; day <= new Date(date.slice(0,7).split('-')[0], date.slice(0,7).split('-')[1], 0).getDate(); day++) {
            const dd = String(day).padStart(2, '0');
            const yyyy = date.slice(0,4);
            const mm = date.slice(5,7);
            const dateStr = `${yyyy}-${mm}-${dd}`;
            if (!logs[dateStr]) logs[dateStr] = {};
            if (!logs[dateStr][sysName]) logs[dateStr][sysName] = {};
            if (!logs[dateStr][sysName][ptName]) logs[dateStr][sysName][ptName] = {};
            const td = document.createElement('td');
            td.className = 'cell';
            let val = logs[dateStr][sysName][ptName][field] ?? '';
            const isCalc = ptObj.calcField === field || ptObj.totalField === field;
            if (isCalc) {
              td.classList.add('computed');
              td.textContent = val;
            } else {
              const inp = document.createElement('input');
              inp.type = 'text';
              inp.className = 'cell-input';
              const isTextField = /comments|chemical added/i.test(field);
              inp.setAttribute('inputmode', isTextField ? 'text' : 'decimal');
              inp.value = val;
              inp.addEventListener('change', () => {
                const value = inp.value;
                logs[dateStr][sysName][ptName][field] = value;
                if (ptObj.meterField === field) {
                  const y = parseInt(yyyy, 10);
                  const m = parseInt(mm, 10);
                  recomputeMakeupForMonth(sysName, ptName, y, m);
                } else {
                  computeMakeupForPoint(dateStr, sysName, ptName);
                  const nextDate = findNextDate(dateStr);
                  if (nextDate) computeMakeupForPoint(nextDate, sysName, ptName);
                }
                saveLogs();
                buildMonthlyGrid();
              });
              td.appendChild(inp);
            }
            applyRangeClass(td, sysName, field, val);
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        });
      });
      table.appendChild(tbody);
      container.appendChild(table);
    }

    // Compute deltas and totals for meter points
    function computeMakeupForPoint(date, sysName, ptName) {
      const sys = config.systems[sysName];
      if (!sys) return;
      const pt = sys.points[ptName];
      const meterField = pt.meterField;
      const calcField = pt.calcField;
      const totalField = pt.totalField;
      if (!meterField || !calcField || !totalField) return;
      const currentVal = logs[date]?.[sysName]?.[ptName]?.[meterField];
      const curr = parseFloat(currentVal);
      if (isNaN(curr)) {
        if (!logs[date][sysName][ptName]) logs[date][sysName][ptName] = {};
        logs[date][sysName][ptName][calcField] = '';
        logs[date][sysName][ptName][totalField] = '';
        return;
      }
      const prevDate = findPreviousDate(date);
      let prev = null;
      if (prevDate && logs[prevDate]?.[sysName]?.[ptName]?.[meterField] !== undefined) {
        prev = parseFloat(logs[prevDate][sysName][ptName][meterField]);
        if (isNaN(prev)) prev = null;
      }
      const delta = prev !== null ? curr - prev : null;
      let total = 0;
      const [year, month] = date.split('-');
      const daysInMonth = new Date(year, month, 0).getDate();
      for (let d = 1; d <= daysInMonth; d++) {
        const dd = String(d).padStart(2,'0');
        const ds = `${year}-${month}-${dd}`;
        if (logs[ds]?.[sysName]?.[ptName]) {
          const v = parseFloat(logs[ds][sysName][ptName][meterField]);
          const prevD = findPreviousDate(ds);
          let pv = null;
          if (prevD && logs[prevD]?.[sysName]?.[ptName]?.[meterField] !== undefined) {
            pv = parseFloat(logs[prevD][sysName][ptName][meterField]);
            if (isNaN(pv)) pv = null;
          }
          if (pv !== null && !isNaN(v)) {
            total += (v - pv);
          }
        }
      }
      if (!logs[date][sysName][ptName]) logs[date][sysName][ptName] = {};
      logs[date][sysName][ptName][calcField] = delta !== null ? (delta >= 0 ? delta.toFixed(2) : '') : '';
      logs[date][sysName][ptName][totalField] = !isNaN(total) && total > 0 ? total.toFixed(2) : '';
    }

    // Find previous date in logs
    function findPreviousDate(date) {
      const dates = Object.keys(logs).filter(d => d < date).sort();
      return dates.length ? dates[dates.length - 1] : null;
    }

    // Find next chronological date
    function findNextDate(date) {
      const d = new Date(date);
      d.setDate(d.getDate() + 1);
      return d.toISOString().slice(0,10);
    }

    // Recompute makeup for entire month for meter changes
    function recomputeMakeupForMonth(sysName, ptName, year, month) {
      const daysInMonth = new Date(year, month, 0).getDate();
      const mm = String(month).padStart(2,'0');
      for (let day = 1; day <= daysInMonth; day++) {
        const dd = String(day).padStart(2,'0');
        const dateStr = `${year}-${mm}-${dd}`;
        computeMakeupForPoint(dateStr, sysName, ptName);
      }
    }

    // Apply range classes
    function applyRangeClass(cell, system, field, value) {
      cell.classList.remove('low-cell','high-cell','ok-cell');
      const key = `${system}|${field}`;
      const range = config.ranges[key];
      const num = parseFloat(value);
      if (!range || isNaN(num)) {
        cell.classList.add('ok-cell');
        return;
      }
      const { low, high } = range;
      if (low !== null && num < low) {
        cell.classList.add('low-cell');
      } else if (high !== null && num > high) {
        cell.classList.add('high-cell');
      } else {
        cell.classList.add('ok-cell');
      }
    }

    // Build monthly grid for selected system and month
    function buildMonthlyGrid() {
      const sysName = document.getElementById('monthlySystem').value;
      const monthStr = document.getElementById('monthlyMonth').value;
      const container = document.getElementById('monthlyGridContainer');
      const titleEl = document.getElementById('monthlyGridTitle');
      // Remove previous table
      while (container.children.length > 1) { container.removeChild(container.lastChild); }
      if (!sysName || !monthStr) {
        titleEl.textContent = 'Monthly View';
        return;
      }
      titleEl.textContent = `${sysName} – ${monthStr}`;
      const [year, month] = monthStr.split('-');
      const sys = config.systems[sysName];
      if (!sys) return;
      const daysInMonth = new Date(year, month, 0).getDate();
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const hr = document.createElement('tr');
      const corner = document.createElement('th');
      corner.textContent = 'Point / Field';
      corner.className = 'sticky-col';
      hr.appendChild(corner);
      for (let d = 1; d <= daysInMonth; d++) {
        const th = document.createElement('th'); th.textContent = d; hr.appendChild(th);
      }
      thead.appendChild(hr);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      Object.entries(sys.points).forEach(([ptName, ptObj]) => {
        ptObj.fields.forEach((field, fieldIdx) => {
          const tr = document.createElement('tr');
          if (fieldIdx === 0) {
            const thPt = document.createElement('th');
            thPt.className = 'sticky-col';
            thPt.textContent = ptName;
            thPt.rowSpan = ptObj.fields.length;
            tr.appendChild(thPt);
          }
          const fieldCell = document.createElement('th');
          fieldCell.textContent = field;
          fieldCell.className = 'sticky-col';
          tr.appendChild(fieldCell);
          for (let day = 1; day <= daysInMonth; day++) {
            const dd = String(day).padStart(2,'0');
            const dateStr = `${year}-${month}-${dd}`;
            if (!logs[dateStr]) logs[dateStr] = {};
            if (!logs[dateStr][sysName]) logs[dateStr][sysName] = {};
            if (!logs[dateStr][sysName][ptName]) logs[dateStr][sysName][ptName] = {};
            let val = logs[dateStr][sysName][ptName][field] ?? '';
            const td = document.createElement('td');
            td.className = 'cell';
            const isCalc = ptObj.calcField === field || ptObj.totalField === field;
            if (isCalc) {
              td.classList.add('computed');
              td.textContent = val;
            } else {
              const inp = document.createElement('input');
              inp.type = 'text';
              inp.className = 'cell-input';
              const isTextField = /comments|chemical added/i.test(field);
              inp.setAttribute('inputmode', isTextField ? 'text' : 'decimal');
              inp.value = val;
              inp.addEventListener('change', () => {
                const value = inp.value;
                logs[dateStr][sysName][ptName][field] = value;
                if (ptObj.meterField === field) {
                  const y = parseInt(year,10);
                  const m = parseInt(month,10);
                  recomputeMakeupForMonth(sysName, ptName, y, m);
                } else {
                  computeMakeupForPoint(dateStr, sysName, ptName);
                  const nextDate = findNextDate(dateStr);
                  if (nextDate) computeMakeupForPoint(nextDate, sysName, ptName);
                }
                saveLogs();
                buildMonthlyGrid();
              });
              td.appendChild(inp);
            }
            applyRangeClass(td, sysName, field, val);
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        });
      });
      table.appendChild(tbody);
      container.appendChild(table);
    }

    // Export monthly view to CSV
    function exportMonthlyCsv() {
      const sysName = document.getElementById('monthlySystem').value;
      const monthVal = document.getElementById('monthlyMonth').value;
      if (!sysName || !monthVal) {
        alert('Select a system and month first.');
        return;
      }
      const [year, month] = monthVal.split('-');
      const sysObj = config.systems[sysName];
      if (!sysObj) return;
      let csv = 'Date,Point,Field,Value\n';
      const daysInMonth = new Date(year, month, 0).getDate();
      for (let day = 1; day <= daysInMonth; day++) {
        const dd = String(day).padStart(2, '0');
        const dateStr = `${year}-${month}-${dd}`;
        Object.entries(sysObj.points).forEach(([ptName, ptObj]) => {
          ptObj.fields.forEach(field => {
            const val = logs[dateStr]?.[sysName]?.[ptName]?.[field] ?? '';
            const safeVal = String(val).replace(/"/g, '""');
            csv += `${dateStr},${ptName},"${field}","${safeVal}"\n`;
          });
        });
      }
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${sysName.replace(/\s+/g, '_')}_${year}-${month}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Export monthly view to Excel
    function exportMonthlyExcel() {
      const sysName = document.getElementById('monthlySystem').value;
      const monthVal = document.getElementById('monthlyMonth').value;
      if (!sysName || !monthVal) {
        alert('Select a system and month first.');
        return;
      }
      const [year, month] = monthVal.split('-');
      const sysObj = config.systems[sysName];
      if (!sysObj) return;
      const rows = [];
      const daysInMonth = new Date(year, month, 0).getDate();
      for (let day = 1; day <= daysInMonth; day++) {
        const dd = String(day).padStart(2,'0');
        const dateStr = `${year}-${month}-${dd}`;
        Object.entries(sysObj.points).forEach(([ptName, ptObj]) => {
          ptObj.fields.forEach(field => {
            const val = logs[dateStr]?.[sysName]?.[ptName]?.[field] ?? '';
            rows.push({ Date: dateStr, Point: ptName, Field: field, Value: val });
          });
        });
      }
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.json_to_sheet(rows, { header: ['Date','Point','Field','Value'] });
      XLSX.utils.book_append_sheet(wb, ws, 'Data');
      const filename = `${sysName.replace(/\s+/g, '_')}_${year}-${month}.xlsx`;
      XLSX.writeFile(wb, filename);
    }

    // Show trend chart for selected filters
    function showTrend() {
      const sys = document.getElementById('trendSystem').value;
      const pt = document.getElementById('trendPoint').value;
      const field = document.getElementById('trendField').value;
      const from = document.getElementById('trendFrom').value;
      const to = document.getElementById('trendTo').value;
      const titleEl = document.getElementById('trendTitle');
      titleEl.textContent = `${sys} – ${pt} – ${field}`;
      const labels = [];
      const dataPoints = [];
      if (!sys || !pt || !field) return;
      const fromDate = from || '0000-00-00';
      const toDate = to || '9999-12-31';
      const dates = Object.keys(logs).filter(d => d >= fromDate && d <= toDate).sort();
      dates.forEach(d => {
        const val = logs[d]?.[sys]?.[pt]?.[field];
        const num = parseFloat(val);
        if (!isNaN(num)) {
          labels.push(d);
          dataPoints.push(num);
        }
      });
      const ctx = document.getElementById('trendChart').getContext('2d');
      if (window.trendChartInstance) {
        window.trendChartInstance.destroy();
      }
      window.trendChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{ label: field, data: dataPoints, borderColor: '#8ab4f8', fill: false }]
        },
        options: {
          responsive: true,
          scales: {
            x: { title: { display: true, text: 'Date' } },
            y: { title: { display: true, text: field }, beginAtZero: false }
          }
        }
      });
    }

    // Event listeners and initialization
    function initEvents() {
      document.querySelectorAll('nav.tabs .tab').forEach(btn => {
        btn.addEventListener('click', () => {
          const target = btn.dataset.target;
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
          btn.classList.add('active');
          document.getElementById(target).classList.add('active');
          if (target === 'monthly') {
            renderSystemOptions();
          } else if (target === 'settings') {
            renderRangesTable();
          } else if (target === 'trends') {
            renderSystemOptions();
          }
        });
      });
      document.getElementById('prevDay').addEventListener('click', () => {
        const dateInput = document.getElementById('dailyDate');
        if (!dateInput.value) return;
        const d = new Date(dateInput.value);
        d.setDate(d.getDate() - 1);
        dateInput.valueAsDate = d;
        buildDailyGrid();
      });
      document.getElementById('nextDay').addEventListener('click', () => {
        const dateInput = document.getElementById('dailyDate');
        if (!dateInput.value) return;
        const d = new Date(dateInput.value);
        d.setDate(d.getDate() + 1);
        dateInput.valueAsDate = d;
        buildDailyGrid();
      });
      document.getElementById('dailyDate').addEventListener('change', buildDailyGrid);
      document.getElementById('dailySystem').addEventListener('change', buildDailyGrid);
      document.getElementById('monthlySystem').addEventListener('change', buildMonthlyGrid);
      document.getElementById('monthlyMonth').addEventListener('change', buildMonthlyGrid);
      document.getElementById('buildMonthly').addEventListener('click', buildMonthlyGrid);
      document.getElementById('monthlyPrint').addEventListener('click', () => { window.print(); });
      document.getElementById('monthlyExport').addEventListener('click', exportMonthlyCsv);
      document.getElementById('monthlyExportExcel').addEventListener('click', exportMonthlyExcel);
      document.getElementById('storageMode').addEventListener('change', async (e) => {
        config.storage.mode = e.target.value;
        if (config.storage.mode === 'firebase') {
          document.getElementById('firebaseConfigSection').style.display = 'block';
        } else {
          document.getElementById('firebaseConfigSection').style.display = 'none';
        }
        await saveConfig();
        await loadLogs();
        buildDailyGrid();
        buildMonthlyGrid();
      });
      document.getElementById('namespace').addEventListener('change', (e) => {
        config.storage.namespace = e.target.value;
        saveConfig();
      });
      document.getElementById('enableFirebase').addEventListener('click', async () => {
        let cfg;
        try {
          cfg = JSON.parse(document.getElementById('firebaseConfig').value);
        } catch (e) {
          alert('Invalid Firebase config JSON');
          return;
        }
        config.storage.firebaseConfig = cfg;
        initFirebase();
        await saveConfig();
        await loadLogs();
        buildDailyGrid();
        buildMonthlyGrid();
        alert('Firebase enabled');
      });
      document.getElementById('addSystem').addEventListener('click', () => {
        const name = prompt('Enter system name:');
        if (!name) return;
        if (config.systems[name]) {
          alert('System already exists'); return;
        }
        config.systems[name] = { points: {} };
        saveConfig();
        renderSystemOptions();
        renderSystemsList();
        renderRangesTable();
      });
      document.getElementById('seedDefaults').addEventListener('click', () => {
        if (!confirm('Seed default systems? This will not overwrite existing systems.')) return;
        seedDefaults();
      });
      document.getElementById('exportBackup').addEventListener('click', () => {
        const backup = { config, logs };
        const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'daily_logs_backup.json';
        a.click();
        URL.revokeObjectURL(url);
      });
      document.getElementById('forceReset').addEventListener('click', () => {
        if (!confirm('This will clear ALL local data (config and logs) and reload the page. Continue?')) return;
        localStorage.removeItem('dailyLogConfig');
        localStorage.removeItem('dailyLogData');
        location.reload();
      });
      document.getElementById('trendSystem').addEventListener('change', () => {
        const sys = document.getElementById('trendSystem').value;
        const ptSelect = document.getElementById('trendPoint');
        ptSelect.innerHTML = '';
        const fieldSelect = document.getElementById('trendField');
        fieldSelect.innerHTML = '';
        if (!sys) return;
        const sysObj = config.systems[sys];
        Object.keys(sysObj.points).forEach(pt => {
          const opt = document.createElement('option'); opt.value = pt; opt.textContent = pt; ptSelect.appendChild(opt);
        });
        ptSelect.dispatchEvent(new Event('change'));
      });
      document.getElementById('trendPoint').addEventListener('change', () => {
        const sys = document.getElementById('trendSystem').value;
        const pt = document.getElementById('trendPoint').value;
        const fieldSelect = document.getElementById('trendField');
        fieldSelect.innerHTML = '';
        if (!sys || !pt) return;
        const fields = config.systems[sys].points[pt].fields;
        fields.forEach(f => {
          const opt = document.createElement('option'); opt.value = f; opt.textContent = f; fieldSelect.appendChild(opt);
        });
      });
      document.getElementById('showTrend').addEventListener('click', showTrend);
    }

    // Initialization function
    async function init() {
      loadConfig();
      // Show Firebase config if needed
      if (config.storage.mode === 'firebase') {
        document.getElementById('firebaseConfigSection').style.display = 'block';
      }
      document.getElementById('storageMode').value = config.storage.mode;
      document.getElementById('namespace').value = config.storage.namespace || DEFAULT_NAMESPACE;
      if (config.storage.firebaseConfig) {
          document.getElementById('firebaseConfig').value = JSON.stringify(config.storage.firebaseConfig);
          initFirebase();
      }
      if (config.storage.mode === 'supabase') {
        initSupabase();
        await remoteLoadConfig();
        await remoteLoadLogs();
      }
      await loadLogs();
      if (Object.keys(config.systems).length === 0) {
        seedDefaults();
      }
      renderSystemOptions();
      renderSystemsList();
      renderRangesTable();
      initEvents();
      const today = new Date().toISOString().slice(0,10);
      document.getElementById('dailyDate').value = today;
      const currentMonth = today.slice(0,7);
      const monthlyMonthInput = document.getElementById('monthlyMonth');
      if (monthlyMonthInput) monthlyMonthInput.value = currentMonth;
      document.getElementById('trendFrom').value = today;
      document.getElementById('trendTo').value = today;
      buildDailyGrid();
    }
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
